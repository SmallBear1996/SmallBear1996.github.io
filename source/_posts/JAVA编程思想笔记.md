---
title: JAVA编程思想笔记
author: XIA
categories:
  - 笔记
tags:
  - JAVA
date: 2019-07-19 21:01:32
---

# 一切都是对象

- 尽管在java中一切都是对象，但操纵的操作符实际是对象的一个引用。例如使用`String s`创建的并不是对象，而是一个引用。
- 对象存放的位置：
  - 寄存器：位于cpu内部，是最快的储存区。由于寄存器的大小限制所以我们不能直接控制他，也无法感知到他的存在。
  - 堆栈：位于RAM，通过堆栈指针的上下移动来快速分配存储空间，java对象的引用就存储在这里。
  - 堆：位于RAM，用来存放对象。
  - 常量存储：通常直接存放在代码内部，因为它是一直不会改变的。
  - 非RAM存储：有些数据存活于程序之外，他们可以不受程序的控制，比如流对象和持久化对象等。他们保存在硬盘中。
- 基本数据类型不存储在堆中，他们直接存储在堆栈中，比如：boolean、inti、long等。

# 操作符

- 当使用直接常量时，可能会产生模棱两可的情况。此时需要在常量后面添加后缀标识符：L（l）代表long类型，F（f）代表float类型，D（d）代表double类型。

# 流程控制

- java中不允许使用数字来代表true和false。即不可以使用非零的数代表true，零代表false。

- 当在循环中使用标签时，使用continue和break关键字可以中断循环，直到标签所在的位置。

  ```java
  //输出的结果中没有i==2的值。
  		outer:
          for (int i = 0; i < 10; i++) {
              inner:
              for (int j = 0; j < 5; j++) {
                  if (i == 2){
                      continue outer;
                  }
                  System.out.println("i = "+i+",j = "+j);
              }
          }
  ```

# 初始化和清理

- 类的构造器必须要与类同名，且没有返回值。

- 区分方法的重载的依据就是方法必须要有独一无二的参数列表

- this关键字：当调用方法时可以看作“发送消息给对象”，但是在发送消息时编译器也作了一些幕后工作，就是将“所操作对象的引用”作为第一个参数传递给方法。如果想在方法中使用当前对象的引用则可以使用this关键字。

- 当在方法中调用当前类的其他方法时可以直接调用无需使用this关键字。

- 可以在构造方法中使用this()调用其他的构造方法，但是必须置于起始位置。

- static方法就是没有this的方法

- 垃圾清理主要讲了finalize方法的问题和垃圾收集的原理，这里留到JAVA虚拟机部分再整理。

- 成员初始化：

  - 类成员变量如果使用前未初始化编译器则会为其设置默认值，对于方法里的局部变量，编译器则会报错。
  - 在构造器被调用之前，类成员的初始化已经完成。

  ```java
  //i先为0,后为1
  public class Init {
      int i;
      public static void main(String[] args) {
          i = 1;
      }
  }
  ```

  - 在类的内部，变量定义的顺序就是初始化的顺序。即使变量定义在方法中间，它们也会在任何方法调用之前得到初始化。
  - 无论创建多少个对象static数据只占用一份存储区域。static关键字不允许用在局部变量。static修饰的变量初始化的值同非static修饰的值。
  - 静态代码块，在首次生成该类的对象或访问属于这个类的静态数据成员时，这段代码就会执行一次。而且只执行一次。
  - 非静态代码块，在每次创建对象时都会执行一次。

- 数组也是对象。数组对象有一个成员变量length，用来查看数组中元素的个数。

- 每个java源代码文件被称为一个编译单元。编译单元必须为.java后缀名。每个编译单元内必须有且只有一个public类，这个类要与编译单元的文件名相同（为了提高编译效率）。

- 默认权限为包访问权限，protected访问权限也提供包访问权限也提供子类的访问权限。
- 类访问权限只可以为public和默认包访问权限。

# 复用类

- 在子类中创建的对象会隐含的包含一个父类的对象。
- 组合就是在一个类中包含另一个类的对象。
- 选择继承还是组合时is-a和has-a的问题。另一个判断标准是是否需要向上转型。
- final关键字的两个场景：
  - 一个永不可变的编译时常量
  - 一个在运行时被初始化的值，而你不希望它被改变
- final允许进行留白，即在声明final时不给出初始值。只要在空白的final使用前被初始化即可。
- final也可以修饰方法中的参数
- final修饰方法，是为了将方法锁定，防止继承类修改他的含义。当方法用private修饰时也隐式的使用了final。因为他都无法取用了，当然也无法被覆盖了呀～～～
- final修饰类，表示这个类无法被继承。
- 继承类的对象初始化顺序：
  - 首先初始化父类的static变量和static代码块，然后是子类的static变量和static代码块。
  - 然后是父类的成员变量，非静态代码块，父类构造方法执行。子类的成员变量初始化，非静态代码块，子类构造方法执行。

# 多态

 