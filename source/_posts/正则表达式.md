---
title: 正则表达式
author: XIA
categories:
  - null
tags:
  - null
date: 2019-07-29 20:02:35
---

# 正则基础

## 元字符

元字符可以看为正则表达式为其预留某些含义的字符，他们有的表示一个单词（在正则表达式中一个\w代表的字符，表示一个单词），有的表示数字，而有的则表示位置信息。常用的元字符如下：

| 代码 |            说明            |
| :--: | :------------------------: |
| `.`  | 匹配除换行符以外的任意字符 |
| `\w` |   匹配字母或数字或下划线   |
| `\s` |      匹配任意的空白符      |
| `\d` |          匹配数字          |
| `\b` |    匹配单词的开始或结束    |
| `^`  |      匹配字符串的开始      |
| `$`  |      匹配字符串的结束      |

这里需要特别说明几点：

- `\w`的范围：在支持*ASCII*码的语言中，如*JavaScript*，“**\w**”等价于*[a-zA-Z0-9_]* ；在支持*Unicode*的语言中，如*.NET*，默认情况下，“**\w**”除可以匹配*[a-zA-Z0-9_]*外，还可以匹配一些*Unicode*字符集，如汉字，全角数字等等。但是在java中，虽然java是支持*Unicode*的语言，但是java中`\w`表示*[a-zA-Z0-9_]* 。
- `\b`的究竟怎么用：“**\b**”匹配的只是一个位置，这个位置的一侧是构成单词的字符（这一侧的左边也应该是为非单词字符），另一侧为非单词字符、字符串的开始或结束位置。“**\b**”是零宽度的。（单词的意思是指一个`\w`表示的内容。零宽度的意思是它只表示位置，而不代表任意字符。）
- `^`与`$`：字符串表示待匹配的字符串，包括换行和空格。

## 重复

重复的意思是前面的元字符或明确的单词要重复的次数。如`\b123{2,5}\b`表示一个要匹配的字符串中应包含一个12开头3重复2到5次的子串。

| 代码/语法 |       说明       |
| :-------: | :--------------: |
|    `*`    | 重复零次或更多次 |
|    `+`    | 重复一次或更多次 |
|    `?`    |  重复零次或一次  |
|   `{n}`   |     重复n次      |
|  `{n,}`   | 重复n次或更多次  |
|  `{n,m}`  |    重复n到m次    |

## 转义字符

有时候在我们查找 . ，或者*，或者一些元字符本身的话，会有一些问题出现，因为这些元字符已经变成别的意思了，所以没有办法指定这些元字符。出现这种情况，就得使用`\`来取消这些字符的特殊意义。所以，应该使用`\.`和`\*`。当然，要查找\本身，需要使用`\\`。

## 字符类

当我们可以使用`\w`表示任意的单词，但是如果我们希望表示一个单词应该是aeiou中的一个时该怎么办，这时候就要使用`[]`了。`[aeiou]`表示中括号中的任意单词都可以被匹配。它还可以表示一个范围，`[0-9]`代表一个数字，它的含意与`\d`就是完全一致的：同理`[a-z0-9A-Z_]`也完全等同于`\w`。

## 分支条件

类似于或用`|`表示。他表示一个正则表达式分为两个或两个以上的部分。只要一部分与待匹配的字符串匹配了，那么就表示匹配成功了。`^138\d{8}$|^188\d{8}$`表示匹配以138开头或者是188开头的手机号。

当分支条件运行时，它将从左往右执行，当有匹配的条件时便停止与后面的正则条件匹配，类似于java的短路或。

##　分组(子表达式)

在字符后面加上限定符就可以重复单个字符，那么多个字符的重复又该如何实现呢？可以使用小括号来指定子表达式（也称为**分组**），然后对于这个子表达式的重复次数就可以自行规定了。

例如：`123{2}`将匹配1233。而`(123){2}`将匹配123123

分组还有一些别的用法，如下所示：

![正则分组](https://xbxblog2.bj.bcebos.com/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F%E6%AD%A3%E5%88%99%E5%88%86%E7%BB%84.png)

## 反义

想象这种场景：我想要匹配除了aeiou之外的字符，该怎么写？难道是把需要匹配的都穷举出来吗？当然不是，使用反义即可轻松搞定。

| 代码/语法  |                             说明                             |
| :--------: | :----------------------------------------------------------: |
|    `\W`    |          匹配任意不是字母，数字，下划线，汉字的字符          |
|    `\S`    |                   匹配任意不是空白符的字符                   |
|    `\D`    |                     匹配任意非数字的字符                     |
|    `\B`    |                 匹配不是单词开头或结束的位置                 |
|   `[^x]`   |                   匹配除了x以外的任意字符                    |
| `[^aeiou]` | 匹配除了aeiou这几个字母以外的任意字符（ 包括空白，换行，数字等） |

## 后向引用

可以将小括号指定的子表达式匹配的内容进行引用，捕获组(一个分组)在匹配成功时，会将子表达式匹配到的内容，保存到内存中一个以数字编号的组里，可以简单的认为是对一个局部变量进行了赋值，这时就可以通过反向引用方式，引用这个局部变量的值。一个捕获组在匹配成功之前，它的内容可以是不确定的，一旦匹配成功，它的内容就确定了，反向引用的内容也就是确定的了。

反向引用必然要与捕获组一同使用的，如果没有捕获组，而使用了反向引用的语法，不同语言的处理方式不一致，有的语言会抛异常，有的语言会当作普通的转义处理。

例如：`\b(\w+)\b\s+\1\b`可以用来匹配重复的单词，像*go go*, 或者*kitty kitty*。他的执行过程是当在捕获组匹配到了go时，此时`\1`将会被赋值为go，此时的正则可以理解为`\b(\w+)\b\s+go\b`

组名可以自己指定也可以自动生成，自动生成的原则为：从左到右以分组的左括号作为标志，把第一次出现的分组的组号定为1，第二个即2，以此类推下去。引用时就使用`\1或\2`。

当自己指定子表达式的**组名**。要指定一个子表达式的组名，请使用这样的语法：`(?<Word>\w+)`(或者把尖括号换成'也行：`(?'Word'\w+))`,这样就把`\w+`的组名指定为`Word`了。要反向引用这个分组捕获的内容，你可以使用`\k<Word>`,所以上一个例子也可以写成这样：`\b(?<Word>\w+)\b\s+\k<Word>\b`。

备注：

>参照分组的图片，我们已经讨论了前两种语法。第三个`(?:exp)`不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？
>其实,组号分配还不像我刚说得那么简单：
>
>- 分组0对应整个正则表达式
>- 实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号
>- 你可以使用`(?:exp)`这样的语法来剥夺一个分组对组号分配的参与权．

## 零宽断言

这一节主要讲匹配的前后符合什么条件才开始匹配，所起的作用类似于\b。

前面在元字符那一节，我们解释了零宽的含义。所谓的零宽可以理解为就是一个位置标志。而断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。

接下来的四个用于查找在某些内容的之前或之后的东西，但是有不包含这些内容本身的时候，零宽断言就起到作用了。也就是说它们像`\b`,`^`,`$`那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为**零宽断言**。最好还是拿例子来说明吧：

`(?=exp)`也叫**零宽度正预测先行断言**，它断言自身出现的位置的后面能匹配表达式exp。比如`\b\w+(?=ing\b)`，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找*I'm singing while you're dancing.*时，它会匹配sing和danc。

`(?<=exp)`也叫**零宽度正回顾后发断言**，它断言自身出现的位置的前面能匹配表达式exp。比如`(?<=\bre)\w+\b`会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找*reading a book*时，它匹配ading。

假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：`((?<=\d)\d{3})+\b`，用它对*1234567890*进行查找时结果是234567890。

下面这个例子同时使用了这两种断言：`(?<=\s)\d+(?=\s)`匹配以空白符间隔的数字(再次强调，不包括这些空白符)。

## 负向零宽断言

匹配前面或后面不是某表达式的情况。只是确保符不符合，并不去匹配。

怎么查找**不是某个字符或不在某个字符类里**的字符的方法（反义）我们之前已经提过了。但是如果我们的目的不是去匹配某个字符，而是只想要该字符是否出现过，怎么办？例如，如果我们想要查找的单词中出现了字母q，但是字母q的后面跟着的不是字母u的话，我们可以尝试：

`\b\w*q[^u]\w*\b`匹配包含**后面不是字母u的字母q**的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像**Iraq,Benq**，这个表达式就会出错。这是因为`[^u]`总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的`[^u]`将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的`\w*\b`将会匹配下一个单词，于是`\b\w*q[^u]\w*\b`就能匹配整个*Iraq fighting*。**负向零宽断言**能解决这样的问题，因为它只匹配一个位置，并不**消费**任何字符。现在，我们可以这样来解决这个问题：`\b\w*q(?!u)\w*\b`（使用这个表达式若用来匹配Iraq fighting时，由于`(?!u)`只是确保时候符合而不做匹配，所以会使用`\w*\b`去匹配q后的空格。所以匹配结果为lraq。若使用`\b\w*q[^u]\w*\b`就不一样了`[^u]`会将q后的空格进行匹配，而`\w*\b`就匹配了空格后的部分，所以最后结果为：Iraq fighting）。

**零宽度负预测先行断言**`(?!exp)`，断言此位置的后面不能匹配表达式exp。例如：`\d{3}(?!\d)`匹配三位数字，而且这三位数字的后面不能是数字；`\b((?!abc)\w)+\b`匹配不包含连续字符串abc的单词。

同理，我们可以用`(?<!exp)`,**零宽度负回顾后发断言**来断言此位置的前面不能匹配表达式exp：`(?<![a-z])\d{7}`匹配前面不是小写字母的七位数字。

一个更复杂的例子：`(?<=<(\w+)>).*(?=<\/\1>)`匹配不包含属性的简单HTML标签内里的内容。`(?<=<(\w+)>)`指定了这样的**前缀**：被尖括号括起来的单词(比如可能是<b>)，然后是`.*`(任意的字符串),最后是一个**后缀**`(?=<\/\1>)`。注意后缀里的`\/`，它用到了前面提过的字符转义；`\1`则是一个反向引用，引用的正是捕获的第一组，前面的`(\w+)`匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。

## 注释

小括号还有另一种用途，就是通过语法`(?#comment)`来包含注释。例如：`2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)`。

## 贪婪与懒惰模式

当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配**尽可能多**的字符。以这个表达式为例：`a.*b`，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串*aabab*。这被称为**贪婪**匹配。

有时，我们更需要**懒惰**匹配，也就是匹配**尽可能少**的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号`?`。这样`.*?`就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：

`a.*?b`匹配最短的，以a开始，以b结束的字符串。如果把它应用于*aabab*的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。

| 代码/语法 |              说明               |
| :-------: | :-----------------------------: |
|   `*?`    |   重复任意次，但尽可能少重复    |
|   `+?`    | 重复1次或更多次，但尽可能少重复 |
|   `??`    |  重复0次或1次，但尽可能少重复   |
| `{n,m}?`  |   重复n到m次，但尽可能少重复    |
|  `{n,}?`  |   重复n次以上，但尽可能少重复   |

> 为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权——The match that begins earliest wins。

# 正则实战

## java

String类提供了三个使用正则表达式的方法：

- .matches(String regex):根据正则表达式进行匹配，若匹配成功返回true。这个方法判断的是整个字符串是否匹配，而不是这个字符串时候存在匹配选项。
- .split(String regex):根据正则表达式匹配对字符串进行切割
- .replaceFirst(String regex,String replacement):将匹配的字符串内容替换为replacement的内容

```java
public class StringRegex {
    public static void main(String[] args) {
        String s = "123abc123abc";
        System.out.println(s.matches("(123abc){2}"));
        System.out.println(Arrays.toString(s.split("\\d+")));
        System.out.println(s.replaceFirst("\\d+", "+"));
        System.out.println(s.replaceAll("\\d+", "+"));
    }
}
//out
true
[, abc, abc]
+abc123abc
+abc+abc
```

除String类提供的正则方法之外，java还有专门用来处理正则的工具。主要由java.util.regex包提供支持。该包下包含两个类Pattern和Matcher。使用方法如下：

```java
public class PMDemo {
    public static void main(String[] args) {
        //编译正则表达式，compile还有一个重载方法，用来表示正则编译模式，具体看文档
        Pattern pattern = Pattern.compile("\\w+");
        //进行匹配，然后才可以进行相关操作
        Matcher m = pattern.matcher("i love java");
        //该方法用来查找字符串中是否还存在匹配的子串
        while (m.find()) {
            //返回由前一个匹配的子串
            System.out.println(m.group());
        }
        //一个Pattern的静态方法用来鉴定字符串时候完全匹配正则
        System.out.println(Pattern.matches("\\w+","i love js"));
    }
}
```

## js

参考：<https://www.runoob.com/js/js-regexp.html>

注意两个事情：

1. regex的exec是专门为捕获组设计的，它返回数组是表示每个捕获组所匹配的字符串，而不是在一个字符串中的每个匹配子串。
2. regex的test方法是检测字符串中是否含有正则匹配的文本。








参考：

> 正则教程：<https://www.w3cschool.cn/regex_rmjc/regex_rmjc-n5a328cn.html>
>
> \b与\w的范围;<https://blog.csdn.net/lxcnn/article/details/4355364>
>
> 反向引用：<https://blog.csdn.net/lxcnn/article/details/4476746>
>
> 正则表达式手册：<https://tool.oschina.net/uploads/apidocs/jquery/regexp.html>
