---
title: Linux笔记
author: XIA
categories:
  - Linux
tags:
  - Linux
date: 2019-06-07 14:21:59
---
# 计算机概论
- 在网络传输时，使用的是bit为单位 ，常见的传输单位Mbit/s。1Byte=8bit。所以当听到网速为8M/1M时，转换为文件容量常用单位Byte时，为1MB/s或128KB/s
- 计算机主板分为南桥和北桥。intel的芯片架构为：北桥负责连接速度较快的CPU、内存、显卡等部件。南桥则负责连接速度较慢的周边接口，包括硬盘、USB、网卡等。
- CPU的频率指的是CPU每秒可以进行的工作次数。如3.0GHz的频率，表示每秒可以进行3.0乘十的九次方次工作，每次工作进行少数指令的运行。不同CPU之间不能通过单纯比较频率来判断性能，因为每个CPU的微指令集不同，架构不同，每次频率处理的工作指令数目也不同。所以频率只能用来比较同款CPU
- CPU外频指与外部组件进行数据传输/运算时的速度。倍频指的是CPU内部用来加速工作性能的一个倍数，两者想乘便是CPU的工作频率。CPU超频主要指的是外频。

## 硬盘分区和磁盘分区

- 机械硬盘的盘片上每个扇区512bytes大小
- 在磁盘的第一个分区包含两部分组成：主引导区(MBR),可以安装引导加载程序的位置，446bytes。分区表，记录硬盘分区情况，64bytes。
- 所谓的分区就是对64字节的分区表进行设置而已
- 硬盘的默认分区表仅能写入四组分区信息，分区分为主分区和扩展分区，主分区+扩展分区只能有四个，这是硬盘决定的。扩展分区只能有一个，由操作系统决定。逻辑分区由扩展分区切割出来。扩展分区无法被格式化。
- 分区的单位是柱面

## 开机流程与主引导分区（MBR）

- CMOS：记录各项硬件参数且嵌入在主板上的储存器。BIOS：开机时计算机执行的第一个程序，也是写在主板上。
- 通过设置BIOS，设置启动的硬盘。然后计算机到该硬盘的第一个扇区找到MBR分区。此时BIOS的工作就完成了
- MBR中包含一个引导加载程序（Boot loader），该程序由操作系统安装时提供。可以用来读取操作系统的内核文件，当读取到操作系统内核文件时，该程序也就完成了任务。
- 引导加载程序一般包含三个功能：提供菜单，用户可以选择不同的开机选项，实现多重引导。载入内核文件，直接指向可开机的程序区来启动操作系统。转交给其他loader，将引导加载功能交给其他loader负责。
- 引导程序除了安装在MBR分区，还可以安装在每个分区的引导扇区。这就是多重引导。当引导程序指向另一个引导程序时，就实现了多重引导。

## 另一种引导方式（UEFI）

当使用GPT格式的硬盘时可以使用UEFI的引导方式，该方式是BIOS引导的进化版。

当硬盘格式为GPT时可以进行无限分区。当使用UFEI引导时装系统时，默认会创建一个ESP分区（UEFI的引导分区）里面会存放关于引导的相关文件。该分区为FAT32文件系统。

当进项双系统安装时引导分区都应设置为一个分区。在安装win与linux双系统时，关闭win的快速启动功能，否则启动电脑时默认进入win系统。

# 命令快捷键

命令行进行命令操作的快捷键：

- ctrl+左右键:在单词之间跳转
- ctrl+a:跳到本行的行首
- ctrl+e:跳到页尾
- Ctrl+u：删除当前光标前面的文字 （还有剪切功能）
- ctrl+k：删除当前光标后面的文字(还有剪切功能)
- Ctrl+L：进行清屏操作
- Ctrl+y:粘贴Ctrl+u或ctrl+k剪切的内容
- Ctrl+w:删除光标前面的单词的字符
- Alt – d ：由光标位置开始，往右删除单词。往行尾删

# 压缩命令

## 两种压缩格式

**.gz格式**

使用gzip压缩的文件，格式为.gz

- -c：将压缩信息输出在屏幕上
- -d：解压缩参数
- -v：在屏幕上显示原文件与压缩文件的压缩比信息

```bash
#对文件进行压缩,对test.sh进行压缩，压缩后原文件会自动删除
gzip test.sh
#解压缩，会自动删除原压缩文件
gzip -d test.sh.gzip
```

**.bz2格式**

bzip2进行压缩后的文件扩展名为.bz2。

- -c：将压缩过程的数据输出到屏幕

- -z：压缩的参数

- -d：解压缩

- -k：保留原文件

  ```bash
  #压缩文件，保留源文件。同`bzip2 -zk test.sh`。
  bzip2 -k test.sh
  ```

## tar

tar是一个打包工具

- -c：对文件进行打包或压缩

- -x：对文件进行解打包和解压缩

- -f：后面接要处理的文件名

- -j：以bzip2进行压缩或解压，扩展名：.bz2

- -z：以gzip进行解压或压缩,扩展名：.gz

- -v：在处理过程中显示处理文件的文件名

- -C：在进行解压缩时，指定要解压到的特定目录

  ```bash
  #对dir文件夹进行打包并以gzip进行压缩
  tar -cvzf dir.tar.gz dir
  #对dir.tar.gz进行解打包与解压缩，指定解压后的文件存储在myDir文件夹中
  tar -zxvf dir.tar.gz -C myDir
  ```

  

# vi & vim

## vi的三种模式

- 一般模式：打开vi默认的模式，该模式下可以移动光标，进行删除，复制，粘贴操作。
- 编辑模式：一般模式下按下i、I、o、O、a、A、r、R进入编辑模式，此模式下可以对内容进行编辑。
- 命令行模式：一般模式下输入：、/、？进入命令行模式。该模式下可以进行查找，保存，显示行号等操作。

## 常用按键

- 第一部份：一般指令模式可用的按钮说明，光标移动、复制贴上、搜寻取代等

| 移动光标的方法                                               |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| h 或 向左方向键（←）                                         | 光标向左移动一个字符                                         |
| j 或 向下方向键（↓）                                         | 光标向下移动一个字符                                         |
| k 或 向上方向键（↑）                                         | 光标向上移动一个字符                                         |
| l 或 向右方向键（→）                                         | 光标向右移动一个字符                                         |
| 如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 列，可以使用 "30j" 或 "30↓" 的组合按键， 亦即加上想要进行的次数（数字）后，按下动作即可！ |                                                              |
| [Ctrl] + [f]                                                 | 屏幕“向下”移动一页，相当于 [Page Down]按键 （常用）          |
| [Ctrl] + [b]                                                 | 屏幕“向上”移动一页，相当于 [Page Up] 按键 （常用）           |
| [Ctrl] + [d]                                                 | 屏幕“向下”移动半页                                           |
| [Ctrl] + [u]                                                 | 屏幕“向上”移动半页                                           |
| +                                                            | 光标移动到非空白字符的下一列                                 |
| -                                                            | 光标移动到非空白字符的上一列                                 |
| n<space>                                                     | 那个 n 表示“数字”，例如 20 。按下数字后再按空白键，光标会向右移动这一列的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。 |
| 0 或功能键[Home]                                             | 这是数字“ 0 ”：移动到这一列的最前面字符处 （常用）           |
| $ 或功能键[End]                                              | 移动到这一列的最后面字符处（常用）                           |
| H                                                            | 光标移动到这个屏幕的最上方那一列的第一个字符                 |
| M                                                            | 光标移动到这个屏幕的中央那一列的第一个字符                   |
| L                                                            | 光标移动到这个屏幕的最下方那一列的第一个字符                 |
| G                                                            | 移动到这个文件的最后一列（常用）                             |
| nG                                                           | n 为数字。移动到这个文件的第 n 列。例如 20G 则会移动到这个文件的第 20 列（可配合 :set nu） |
| gg                                                           | 移动到这个文件的第一列，相当于 1G 啊！ （常用）              |
| n<Enter>                                                     | n 为数字。光标向下移动 n 列（常用）                          |
| 搜寻与取代                                                   |                                                              |
| /word                                                        | 向光标之下寻找一个名称为 word 的字串。例如要在文件内搜寻 vbird 这个字串，就输入 /vbird 即可！ （常用） |
| ?word                                                        | 向光标之上寻找一个字串名称为 word 的字串。                   |
| n                                                            | 这个 n 是英文按键。代表“<u>重复前一个搜寻的动作</u>”。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字串！ |
| N                                                            | 这个 N 是英文按键。与 n 刚好相反，为“反向”进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示“向上”搜寻 vbird 。 |
| 使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键字！ |                                                              |
| :n1,n2s/word1/word2/g                                        | n1 与 n2 为数字。在第 n1 与 n2 列之间寻找 word1 这个字串，并将该字串取代为 word2 ！举例来说，在 100 到 200 列之间搜寻 vbird 并取代为 VBIRD 则：“:100,200s/vbird/VBIRD/g”。（常用） |
| :1,$s/word1/word2/g                                          | 从第一列到最后一列寻找 word1 字串，并将该字串取代为 word2 ！（常用） |
| :1,$s/word1/word2/gc                                         | 从第一列到最后一列寻找 word1 字串，并将该字串取代为 word2 ！且在取代前显示提示字符给使用者确认 （confirm） 是否需要取代！（常用） |
| 删除、复制与贴上                                             |                                                              |
| x, X                                                         | 在一列字当中，x 为向后删除一个字符 （相当于 [del] 按键）， X 为向前删除一个字符（相当于 [backspace] 亦即是倒退键） （常用） |
| nx                                                           | n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， “10x”。 |
| dd                                                           | 删除光标所在的那一整列（常用）                               |
| ndd                                                          | n 为数字。删除光标所在的向下 n 列，例如 20dd 则是删除 20 列 （常用） |
| d1G                                                          | 删除光标所在到第一列的所有数据                               |
| dG                                                           | 删除光标所在到最后一列的所有数据                             |
| d$                                                           | 删除光标所在处，到该列的最后一个字符                         |
| d0                                                           | 那个是数字的 0 ，删除光标所在处，到该列的最前面一个字符      |
| yy                                                           | 复制光标所在的那一列（常用）                                 |
| nyy                                                          | n 为数字。复制光标所在的向下 n 列，例如 20yy 则是复制 20 列（常用） |
| y1G                                                          | 复制光标所在列到第一列的所有数据                             |
| yG                                                           | 复制光标所在列到最后一列的所有数据                           |
| y0                                                           | 复制光标所在的那个字符到该列行首的所有数据                   |
| y$                                                           | 复制光标所在的那个字符到该列行尾的所有数据                   |
| p, P                                                         | p 为将已复制的数据在光标下一列贴上，P 则为贴在光标上一列！ 举例来说，我目前光标在第 20 列，且已经复制了 10 列数据。则按下 p 后， 那 10 列数据会贴在原本的 20 列之后，亦即由 21 列开始贴。但如果是按下 P 呢？ 那么原本的第 20 列会被推到变成 30 列。 （常用） |
| J                                                            | 将光标所在列与下一列的数据结合成同一列                       |
| c                                                            | 重复删除多个数据，例如向下删除 10 列，[ 10cj ]               |
| u                                                            | 复原前一个动作。（常用）                                     |
| [Ctrl]+r                                                     | 重做上一个动作。（常用）                                     |
| 这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！ |                                                              |
| .                                                            | 不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点“.”就好了！ （常用） |

- 第二部份：一般指令模式切换到编辑模式的可用的按钮说明

| 进入插入或取代的编辑模式                                     |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| i, I                                                         | 进入插入模式（Insert mode）：i 为“从目前光标所在处插入”， I 为“在目前所在列的第一个非空白字符处开始插入”。 （常用） |
| a, A                                                         | 进入插入模式（Insert mode）：a 为“从目前光标所在的下一个字符处开始插入”， A 为“从光标所在列的最后一个字符处开始插入”。（常用） |
| o, O                                                         | 进入插入模式（Insert mode）：这是英文字母 o 的大小写。o 为“在目前光标所在的下一列处插入新的一列”； O 为在目前光标所在处的上一列插入新的一列！（常用） |
| r, R                                                         | 进入取代模式（Replace mode）：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；（常用） |
| 上面这些按键中，在 vi 画面的左下角处会出现“--INSERT--”或“--REPLACE--”的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在文件里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！ |                                                              |
| [Esc]                                                        | 退出编辑模式，回到一般指令模式中（常用）                     |

- 第三部份：一般指令模式切换到命令行界面的可用按钮说明

| 命令行界面的储存、离开等指令                                 |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| :w                                                           | 将编辑的数据写入硬盘文件中（常用）                           |
| :w!                                                          | 若文件属性为“只读”时，强制写入该文件。不过，到底能不能写入， 还是跟你对该文件的文件权限有关啊！ |
| :q                                                           | 离开 vi （常用）                                             |
| :q!                                                          | 若曾修改过文件，又不想储存，使用 ! 为强制离开不储存盘案。    |
| 注意一下啊，那个惊叹号 （!） 在 vi 当中，常常具有“强制”的意思～ |                                                              |
| :wq                                                          | 储存后离开，若为 :wq! 则为强制储存后离开 （常用）            |
| ZZ                                                           | 这是大写的 Z 喔！若文件没有更动，则不储存离开，若文件已经被更动过，则储存后离开！ |
| :w [filename]                                                | 将编辑的数据储存成另一个文件（类似另存新文件）               |
| :r [filename]                                                | 在编辑的数据中，读入另一个文件的数据。亦即将 “filename” 这个文件内容加到光标所在列后面 |
| :n1,n2 w [filename]                                          | 将 n1 到 n2 的内容储存成 filename 这个文件。                 |
| :! command                                                   | 暂时离开 vi 到命令行界面下执行 command 的显示结果！例如 “:! ls /home”即可在 vi 当中察看 /home 下面以 ls 输出的文件信息！ |
| vim 环境的变更                                               |                                                              |
| :set nu                                                      | 显示行号，设置之后，会在每一列的字首显示该列的行号           |
| :set nonu                                                    | 与 set nu 相反，为取消行号！                                 |

## vim环境设置与记录

- 每次使用vim的记录都会被记录下来。这些信息将保存到~/.viminfo文件中

- vim的设置文件保存在/etc/vimrc文件中。但是不建议更改该文件，可以设置单用户的设置，新建~/.vimrc文件，并对vim进行设置。

- 常用设置：

  ```bash
  set nu  "开启行号显示"
  syntax on  "语法排错"
  set autoindent  "自动缩排"
  ```

  

# bash shell

## what?

shell是可以用来调用操作系统功能的一个软件，操作系统管理硬件。

使用shell也可以调用别的软件。

linux将可以使用的shell保存在/etc/shells文件中，当用户登录后根据/etc/passwd文件获取用户使用的shell

bash shell是linux默认的shell

## bash shell的功能

- 命令记忆功能：用户使用的命令可以记忆下来，通过上下键可以进行选择和查看。被使用过的命令记录在~/.bash_history文件内。但是该文件只是记录之前登录的命令，这次登录使用的命令则存储在内存中，只有注销系统时才会存储在~/.bash_history文件中。
- 命令与文件名补全功能：tab键的使用
- 设置别名
- 作业控制、前台、后台控制
- 程序脚本（shell script）

## 命令的执行

当命令过长时可以使用`\回车`进行换行

## 变量

### 变量的设置和显示

- 变量设置`name=xbx`。等号两边不可以包含空格，变量名只可以包含字母和数字，且不可以以数字开头

- 变量的内容若包含空格则使用单引号或双引号将其包裹起来，但是若引号中包含变量,单引号中原样输出，双引号中则取出变量中的内容后输出：

  ```bash
  name=xbx
  hi='hello $name'        输出：hello $name
  hi="hello $name"        输出：hello xbx
  ```
  
- 设置变量时使用`\特殊字符`进行转义

- 当变量中包含其他命令时可以使用反单引号或$(命令)

  ```bash
  version=`uname -r`
  version=$(uname -r)
  
  echo $version
  2.168-128.el5
  ```

- 对已经存在的变量进行增加内容时：

  ```bash
  PATH="$PATH":/home/bin
  ```

- 若该变量需要在子线程执行，则需要以export来使变量变成环境变量

  ```bash
  export PATH
  ```

- 取消某个变量时使用unset命令

  ```bash
  unset name
  ```

- 一般大写字符为系统默认变量，自行设置的变量可以使用小写字符（纯粹依据用户喜好）

### 常用变量及功能

env命令可以查看当前环境下的所有环境变量，常用环境变量如下：

- HOME:用户的主文件夹
- SHELL：目前环境使用的shell
- PATH：执行文件的查找路径，以`:`分隔

set命令可以查看当前环境下所有环境变量与自定义变量

- PS1：提示符设置
- $：本shell的PID，使用`echo $$`显示
- ？：上次执行命令的回传码，一般0为成功,使用`echo ?`显示

export：将自定义变量转换成环境变量。环境变量可以被子线程引用而自定义变量只能在当前bash环境中使用。使用时`export 变量名`即可

**为什么环境变量可以被子线程引用？**

当启动一个shell时，操作系统会分配一块内存给shell使用，此内存中的变量可以被子进程取用。若父进程使用export功能，可以让自定义变量写入上述内存中。当加载另一个shell（即启动子线程），子shell可以将父shell的环境变量所在的内存导入到自己的环境变量内存中。

### 变量的键盘读取、数组与声明（read、array、declare）

- 键盘读取：read

  使用read命令可以读取键盘输入:-p,设置提示信息。-t，设置等待时间。

  ```bash
  read -p "please keying your name: " -t 30 name
  ```

- 变量声明：declare/typeset

  - 这两个命令作用相同，都是声明变量类型。

  - 当不添加任何参数时列出所有变量，类似set命令。

  - bash的便量默认都是字符串类型

  - declare参数：-a，定义变量为数组。-i，声明变量为整数类型。-x，将后面的变量声明为环境变量。-r，设置变量为只读类型。

    ```bash
    declare -ix sum=100        声明变量sum为整数类型且为环境变量
    
    var[0]=xia                 声明数组与取用数组内的数据
    var[1]=bao
    var[2]=xin
    
    echo "${var[0]},${var[0]},${var[0]}" 
    ```
### 限制用户资源的ulimit

  用户在系统中能够使用的资源可以通过相关设置进行限制，如：开启的进程数，使用cpu的最大时间等。可以使用ulimit命令进行设置。

  该命令的一些参数：-a,后面不接参数列出所有限制信息。-f，可以创建的最大文件大小。-u，单一用户可以使用的最大进程。-t，可以使用的最大cpu时间。

### 变量内容的删除、替换和微调

  变量的内容可以通过相关的操作进行一些微调，可以查看鸟哥313页。

## bash shell的操作环境

### 登录与欢迎信息

用户登录后显示的信息存储在/etc/issue与/etc/motd中

### bash环境的配置文件

当我们登录到bash中时什么都没有操作怎么就会有一堆变量了呢？这就是由linux中的配置文件决定的。系统启动后会默认读取一些配置文件来为bash提供初始的变量与别名的设置。

**当用户登录系统后读取配置文件的顺序(login shell)：**

1. 首先读取系统整体的配置文件：/etc/profile。该配置文件主要设置了PATH、MAIL、HISTSIZE等内容，一般情况下不要对该文件进行修改。该文件会对一下文件进行调用来对系统进行设置：

   - 对/etc/profile.d/下的*.sh文件进行调用，这个目录下的文件对ll、ls、which等命令进行了别名设置。当需要对系统中的命令进行初始的别名设置时可以在该文件夹下新建sh文件进行设置。
   - /etc/inptrc：当用户有自定义输入按键功能时会设置`INPUT=/etc/inptrc`变量
   - /etc/sysconfig/i18n:决定bash使用何种语言

2. 当bash读取/etc/profile设置完整体环境后，接下来会读取个人设置文件。当读取个人配置文件时会对三个配置文件进行读取，读取时从上到下依次检索，只读取一个。~/.bash_profile、~/.bash_login、~/.profile。一般centos默认提供~/.bash_profile文件，该文件包含默认含有两个作用：

   - 读取~/.bashrc文件。该文件默认只有有一个功能：读取/etc/bashrc文件，/etc/bashrc设置用户的PS1变量。用户的个人设置可以在~/.bashrc文件中设置如：设置别名与变量等。
   - 进一步设置PATH变量，为该变量添加路径$HOME/bin文件夹。并设置PATH为环境变量。所以当执行文件位于$HOME/bin文件夹内时也可以在任意地方使用。

3. 其他的配置文件，这些配置文件和bash没有相关性但是会影响到bash的操作。

   - ~/.bash_history文件：当登录到bash后会将该文件中记录的历史命令记录加载到内存中
   - ~/.bash_logout文件：此文件记录了当注销bash后再帮我做的事情

**no-login shell 仅读取~/.bashrc文件**

### source命令使用

当某个环境配置文件发生改变时，可以通过`source 改变的文件`或`. 改变的文件`进行重新加载。这两种加载方式效果相同，后一种时前一种的简写。

###   bash默认组合键

​	ctrl+c   终止目前命令

​	ctrl+s   暂停屏幕输出

​	ctrl+q   恢复屏幕输出

​	ctrl+u    删除整行命令

​	ctrl+z     暂停目前命令

## 数据流重定向

**重定向**

重定向就是将原本输出到屏幕上的信息输出保存到文件中。重定向分为标准输出、标准错误输出、标准输入。

- 标准输入：代码为0，使用<或<<
- 标准输出：代码为1，使用>或>>
- 标准错误输出：代码为2，使用2>或2>>

`>`为覆盖输出，`>>`为累加输出

标准输出与标准错误输出的区别：当命令正常执行时输出的内容为标准输出，当命令有错误产生时输出的错误信息为标准错误输出。

   ```bash
#标准输出到find文件，错误标准输出到find2文件
find / > ~/find 2>find2
#当标准输出与标准错误输出都输出到同一个文件时
find / &> ~/find
   ```

**命令连接**

- 不考虑命令之间的相关性，使用`;`

  ```bash
  sync; sync; shutdown -r now
  ```

- 考虑命令的相关性`||与&&` ，原理为前一个命令执行完成后的回传码决定是否执行下一个命令。

  
  
  | 命令执行情况   | 说         明                                                |
  | -------------- | ------------------------------------------------------------ |
| `cmd1 && cmd2`   | 若cmd1执行完毕且正确执行（$?=0）,则开始执行cmd2<br>若cmd1执行完毕且为错误（$?!=0）,则cmd2不执行 |
  | `cmd1 ll cmd2` | 若cmd1执行完毕且正确执行（$?=0）,则cmd2不执行<br>若cmd1执行完毕且为错误（$?!=0）,则开始执行cmd2 |
  
  ```bash
  #验证是否存在该文件夹
  ls /tmp/xbx && echo 'exist' || echo  'not exist'
  ```

## 管道命令

使用管道符`|`连接命令时，可以将前一个命令的标准输出输入到下一个命令，使用管道操作符需要满足两个条件：

1. 管道符后的命令只会获取前一个命令的标准输出，无法获取标准错误输出
2. 管道符后的命令需要支持标准输入

### 选取命令（cut与grep）

**cut命令**

cut命令是用来切割字符串的，支持三个参数：

- -d，后接分隔符表示以什么符号为分割标志进行分割。
- -f，根据-d的分割结果，-f后跟数字表示取出结果的哪一段。
- -c，以字符为单位取出指定区间内的字符。

```bash
#以：为分隔符，取出第4段与第5段字符
echo $PATH | cut -d ':' -f 4,5
#取出$PATH中的第5-10个字符
echo $PATH | cut -c 5-10
```

**grep命令**

grep分析一行数据，若一行中有我们想要的数据则拿出此行。grep支持以下参数：

- -c：计算找到所要查找的字符串找到的次数
- -i：忽略大小写
- -n：顺便输出行号
- -v：反向选择，即显示没有所要查找字符串的那一行

```bash
#输出包含xbx的总行数
last | grep -c 'xbx'
```

### 排序命令（sort、wc、uniq）

**排序：sort**

该命令可以对内容进行排序，以行为单位。支持的参数：

- -f：忽略大小写

- -n：以纯数字方式进行排序，默认以字符的方式进行排序

- -r：反向排序

- -t：分隔符，默认以tab进行分隔

- -k：根据指定空间进行排序

  ```shell
  #对/etc/passwd中内容，以：为分割符，对第三块内容进行排序
  cat /etc/passwd | sort -t ':' -k 3
  ```

**去重：uniq**

对输入的内容，当出现相同的多行时，仅保留一行。支持参数：

- -i：忽略大小写

- -c：进行计数

  ```shell
  last | uniq -c
  ```

**统计：wc**

对输入内容的行数，字符，字数（单词）进行统计

- -i ：仅列出行

- -w：仅列出多少字

- -m：列出多少字符

  ```bash
  #依次列出行，字，字符
  [xbx@instance-8 ~]$ last | wc
       10      89     654
  
  ```

### 双向重定向

当需要将标准输出既要保存到文件中，又要输出到屏幕时可以使用tee命令进行双向重定向

```bash
#将last命令的结果既输出到屏幕上也重定向到lastLog文件中
last | tee lastLog
```

# Shell Script

## 什么是sehll script

shell script是可以在unix like系统中执行的脚本文件。执行方式：

- 通过`sh 脚本名`或`bash 脚本名`进行运行，/bin/sh是/bin/bash的链接文件，所以这两种方式执行是一样的。这种方式执行不需要为脚本赋予x权限。此方式在子线程中执行。

- 通过路径执行。通过绝对路径或相对路径执行。或使用PATH变量指定的路径直接执行。此种执行方式需要对脚本赋予x权限。此方式在子线程中执行。

- 通过`source命令`或`.`执行。这种方式执行时会在当前线程中执行。这也时为什么当修改变量配置文件时使用该命令可以在不注销系统的情况下重新加载变量配置文件。

  ```shell
  #指定该脚本使用的bash名称
  #!/bin/bash
  echo $PATH
  ```

## 测试判断

使用test命令可以进行判断，如判断文件是否存在，文件的权限信息，整数，字符串比较等功能。test后可接不通参数以进行不同的测试判断。

也可以通过中括号进行测试判断。注意中括号中的空格，`[ -e hello ] && echo 'yes' || echo 'no'`作用同test命令。

- -e：判断文件名是否存在
- -f：判断文件名是否为文件
- -d：判断文件名是否为目录
- -r/w/x：判断文件是否具有该权限
- 判断两个字符串是否相同时可以用=或者==
- 。。。。。。。。。鸟哥p380

```bash
#测试hello文件是否存在
test -e hello && echo 'yes' || echo 'no'
#判断name与name1变量的值是否相同，判断字符串时最好使用双引号包裹变量，防止变量内容含有空格
[ "$name" == "$name1" ] && echo 'yes' || echo 'no'
```

## 默认变量

当执行sh脚本时可以默认传入一些参数，就像执行java程序时的传入参数，不同的是java保存到数组，而sh保存到一些默认变量中。

- $#：代表后接的参数的个数
- $@：代表$1,$2等，对应从左到右传入的参数，$0代表命令本身
- $*：代表所有参数，以空格分开

```shell
#!/bin/bash
echo $0 $1 $2 $3
echo $#
echo $*
```

## if语句

语法：

```bash
#!/bin/bash

#多条件判断
if [ "$1" == "y" ] || [ "$1" == "Y" ]; then
        echo "yes"
fi

#elif 使用
if [ "$1" == "hello" ]; then
        echo "hello how are you ?"
elif [ "$1" == "" ]; then
        echo "not null"
else
        echo "only hello"
fi
```

## case语句

语法：

```bash
#!/bin/bash
case $1 in
        "one")
           echo "your choice is one"
           ;;
        "two")
           echo "your choice is two"
           ;;
        *)  #通配符
           echo "usage $0 {one|two|three}"
           ;;
esac
```

## function

- 函数定义要在使用之前
- 函数中可以访问内置变量，$0,$1,$2,$3。$0为函数名。其他为传入的参数值，函数中使用内置变量不会访问到shell脚本的内置变量

```bash
#!/bin/bash
#定义函数，由于sh脚本是从上到下，从左到右执行，所以定义要在使用之前
#function中可以访问变量，使用$1,$2。
function pname ( ) {
  echo "your choice is $1"
}

case $1 in
        "one")
          #调用函数 并进行传参
          pname 1
        ;;
        "two")
          pname 2
        ;;
        "three")
          pname 3
        ;;
        *)
          echo "{one|two|three}"
        ;;
esac
```

## while语句

语法：

```bash
#!/bin/bash
#求1+2+3+...+100的值
declare -i sum=0
declare -i i=1

while [ "$i" -le "100" ]
do
        sum=$sum+$i
        i=$i+1
done

echo $sum
```

## for语句

for...in 语句：对in后的结果进行循环，每次的结果存在in之前的变量中

```bash
#!/bin/bash
#循环输出1-100之间的数
for i in `seq 1 100`
do
        echo $i
done
```

for循环：

```bash
#!/bin/bash
for (( i=1; i<=100; i++ ))
do
        echo $i
done
```

## shell script的调试与追踪

在执行sh脚本时添加一些参数可以对脚本进行调试：

- -x：将使用到的sh内容显示到屏幕上
- -n：不执行脚本，仅检查语法错误
- -v：执行脚本前先将脚本内容输出到屏幕上

# 账号管理与ACL权限

## 用户标识符：UID、GID

linux中的每一个文件都至少会有两个id：UID和GID。分别用来标识该文件的所属用户和所属用户组。

当每个用户登录系统后，linux并不会认识你的登录名，他是根据/etc/passwd中的内容进行对应获取相应的用户UID，之后使用UID作为用户的标识符。

用户的用户组信息存储在/etc/group文件中。

## 用户账号

**用户登录流程：**

1. 先寻找/etc/passwd文件，验证是否包含此账号。没有则直接退出，有的话将该账号对应的UID与GID读出来，另外，该账号的主文件夹与shell设置也将一并读出来
2. 核对密码，此时linux会进入/etc/shadow文件中，找出该账号对应的密码进行核对
3. 通过以上两个阶段则进入shell的管控阶段

**/etc/passwd文件结构**

````bash
xbx:x:500:501::/home/xbx:/bin/bash
````

该文件每一行代表一个用户信息，通过`:`进行分割，共七个字段。依次为：账号名称，密码（已舍弃，现在存储在/etc/shadow内），UID（0为系统管理员，1-499为系统账号 ，500以后为可登录账号），GID，用户信息说明，主文件夹，Shell。

**/etc/shadow文件结构**

````bash
xbx:*:18063:0:99999:7:::
````

该文件存储账号的密码信息，同样以`:`进行分隔，共九个字段。分别为：账号名称，加密后的密码（密码前加！或*可以使密码失效），最近密码变更日期，密码不可变更天数，密码需要重新修改的天数，密码需要修改前的警告天数，密码过期后的账号宽限日期，账号失效日期，保留字段。

## 有效与初始用户组：groups，newgrp

用户的用户组信息存储在/etc/group文件内。当用户登录系统后在/etc/passwd内存储的GID信息对应到该文件。

**/etc/group文件结构**

````bash
video:x:39:xbx,xbx189651
````

每一行代表一个用户组，以分号进行分隔。共四列，分别为：用户组名称，用户组密码（一般为x），GID，此用户组支持的账号。当需要调整用户组中的用户时只需要修改该文件的最后一列，进行添加或删除用户即可。

**初始用户组**

一个用户可以同时存在于多个用户组。用户在/etc/passwd文件中保存的GID对应的用户组就是用户的初始用户组。当用户登录系统后默认使用的就是该用户组。

**有效用户组**

用户当前正在使用的用户组就是有效用户组。

可以使用`groups`命令进行查看该用户所支持的用户组。输出信息的第一个用户组便是有效用户组。

更改有效用户组可以使用`newgrp`命令。当切换有效用户组时实际上时打开了一个新的shell，在打开新shell时为该shell赋予所要切换到的用户组。

```bash
[xbx@instance-8 ~]$ groups            #查看支持的用户组
xbx adm video dip google-sudoers
[xbx@instance-8 ~]$ i=1               #设置临时变量
[xbx@instance-8 ~]$ echo $i           #验证
1
[xbx@instance-8 ~]$ newgrp adm        #切换用户组
[xbx@instance-8 ~]$ echo $i           #切换用户组后打开新的shell，原来的变量没有了

```

**/etc/gshadow文件结构**

```bash
adm:::adm,daemon,xbx,xbx189651
```

该文件主要用来设置用户组管理员使用，不过现在一般不设置这个玩意。该文件每行代表一个用户组，每行通过冒号分隔，共四个字段，分别为：用户组名，密码列（当午用户组管理员时，该项为！），用户组管理员账号，用户组的所属账号（与/etc/group相同）。

## 账号管理（增加、删除、修改）

**用户增加：useradd**

使用useradd命令可以增加用户。在增加用户是结合相应参数可以设置该用户的一些初始化信息。

```bash
[root@study ~]# useradd [-u UID] [-g 初始群组] [-G 次要群组] [-mM]\
&gt;  [-c 说明栏] [-d 主文件夹绝对路径] [-s shell] 使用者帐号名
选项与参数：
-u  ：后面接的是 UID ，是一组数字。直接指定一个特定的 UID 给这个帐号；
-g  ：后面接的那个群组名称就是我们上面提到的 initial group 啦～
      该群组的 GID 会被放置到 /etc/passwd 的第四个字段内。
-G  ：后面接的群组名称则是这个帐号还可以加入的群组。
      这个选项与参数会修改 /etc/group 内的相关数据喔！
-M  ：强制！不要创建使用者主文件夹！（系统帐号默认值）
-m  ：强制！要创建使用者主文件夹！（一般帐号默认值）
-c  ：这个就是 /etc/passwd 的第五栏的说明内容啦～可以随便我们设置的啦～
-d  ：指定某个目录成为主文件夹，而不要使用默认值。务必使用绝对路径！
-r  ：创建一个系统的帐号，这个帐号的 UID 会有限制 （参考 /etc/login.defs）
-s  ：后面接一个 shell ，若没有指定则默认是 /bin/bash 的啦～
-e  ：后面接一个日期，格式为“YYYY-MM-DD”此项目可写入 shadow 第八字段，
      亦即帐号失效日的设置项目啰；
-f  ：后面接 shadow 的第七字段项目，指定密码是否会失效。0为立刻失效，
      -1 为永远不失效（密码只会过期而强制于登陆时重新设置而已。）
```

创建用户时系统所作的工作：

- 在 /etc/passwd 里面创建一行与帐号相关的数据，包括创建 UID/GID/主文件夹等；
- 在 /etc/shadow 里面将此帐号的密码相关参数填入，但是尚未有密码；
- 在 /etc/group 里面加入一个与帐号名称一模一样的群组名称；
- 在 /home 下面创建一个与帐号同名的目录作为使用者主文件夹，且权限为 700

在新建用户时，默认的一些参数值如：默认用户组，默认主文件夹位置，默认shell等信息。这些信息都保存在/etc/default/useradd文件中。使用`useradd -D`可以查看新增用户时的默认设置。

新增用户的默认UID/GID的设置保存在/etc/login.defs中。

用户主目录内的内容的基准目录为/etc/skel。当新建用户时，系统会将该目录下的文件复制到新用户的主目录中。

------

**设置密码：passwd**

当使用了useradd命令新增用户后，并没有设置用户的登录密码。所以还需使用passwd命令为用户设置登录密码。

```bash
[root@study ~]# passwd [-l] [-u] [--stdin] [-S] \
&gt;  [-n 日数] [-x 日数] [-w 日数] [-i 日期] 帐号 &lt;==root 功能
选项与参数：
--stdin ：可以通过来自前一个管线的数据，作为密码输入，对 shell script 有帮助！
-l  ：是 Lock 的意思，会将 /etc/shadow 第二栏最前面加上 ! 使密码失效；
-u  ：与 -l 相对，是 Unlock 的意思！
-S  ：列出密码相关参数，亦即 shadow 文件内的大部分信息。
-n  ：后面接天数，shadow 的第 4 字段，多久不可修改密码天数
-x  ：后面接天数，shadow 的第 5 字段，多久内必须要更动密码
-w  ：后面接天数，shadow 的第 6 字段，密码过期前的警告天数
-i  ：后面接“日期”，shadow 的第 7 字段，密码失效日期
```

当root用户使用该命令时可以后面接账号名为指定账号设置密码。当普通用户使用该命令时可以为自己设置密码。

```bash
范例一：请 root 给予 vbird2 密码
[root@study ~]# passwd vbird2

范例二：用 vbird2 登陆后，修改 vbird2 自己的密码
[vbird2@study ~]$ passwd   &lt;==后面没有加帐号，就是改自己的密码！
```

可以通过`passwd -S`或`chage`命令查看密码设置的历史记录

----

**用户修改：usermod**

可以使用usermod命令对用户的信息进行修改，如修改主文件夹，初始用户组，次要用户组等。

```bash
[root@study ~]# usermod [-cdegGlsuLU] username
选项与参数：
-c  ：后面接帐号的说明，即 /etc/passwd 第五栏的说明栏，可以加入一些帐号的说明。
-d  ：后面接帐号的主文件夹，即修改 /etc/passwd 的第六栏；
-e  ：后面接日期，格式是 YYYY-MM-DD 也就是在 /etc/shadow 内的第八个字段数据啦！
-f  ：后面接天数，为 shadow 的第七字段。
-g  ：后面接初始群组，修改 /etc/passwd 的第四个字段，亦即是 GID 的字段！
-G  ：后面接次要群组，修改这个使用者能够支持的群组，修改的是 /etc/group 啰～
-a  ：与 -G 合用，可“增加次要群组的支持”而非“设置”喔！
-l  ：后面接帐号名称。亦即是修改帐号名称， /etc/passwd 的第一栏！
-s  ：后面接 Shell 的实际文件，例如 /bin/bash 或 /bin/csh 等等。
-u  ：后面接 UID 数字啦！即 /etc/passwd 第三栏的数据；
-L  ：暂时将使用者的密码冻结，让他无法登陆。其实仅改 /etc/shadow 的密码栏。
-U  ：将 /etc/shadow 密码栏的 ! 拿掉，解冻啦！
```

----

**用户删除：userdel**

当需要对用户进行删除时使用userdel命令。删除时删除的数据有：

- 使用者帐号/密码相关参数：/etc/passwd, /etc/shadow
- 使用者群组相关参数：/etc/group, /etc/gshadow
- 使用者个人文件数据： /home/username, /var/spool/mail/username..

```bash
#删除用户名为xbx的用户，-r表示一同删除用户的主文件夹
userdel -r xbx
```

## 用户组管理（增加、删除、修改）

**新增用户组：groupadd**

```bash
[root@study ~]# groupadd [-g gid] [-r] 用户组名称
选项与参数：
-g  ：后面接某个特定的 GID ，为新建的用户组指定GID
-r  ：新建系统用户组。与 /etc/login.defs 内的 GID_MIN 有关。
```

**修改用户组：groupmod**

```bash
[root@study ~]# groupmod [-g gid] [-n group_name] 用户组名
选项与参数：
-g  ：修改GID；
-n  ：修改用户组名称
```

**删除用户组：groupdel**

```bash
[root@study ~]# groupdel [groupname]
```

只有当被删除的用户组下没有用户时，用户组才可以被删除。

## ACL

什么是ACL：

ACL是Access Control List的缩写。他是一套独立的权限管理工具，它可以对文件夹，文件进行按用户，用户组进行权限的定义。

主要包含两个命令：getfacl和setfacl。分别为设置和获取acl权限。

## 用户身份切换

linux系统尽量使用一般账号进行登录操作，这样可以防止出现错误发生的情况。而且以较低的权限运行程序也比较安全，往往有时候某些软件也是不允许使用root账号进行运行，以减少软件被攻破带来的损失。

**su：切换用户**

su命令可以用来切换用户，如将一般账号切换到root账号（需要root密码），或将root账号切换到一般账号（不需要密码）。

```bash
[root@study ~]# su [-lm] [-c 指令] [username]
选项与参数：
-   ：单纯使用 - 如“ su - ”代表使用 login-shell 的变量文件读取方式来登陆系统；
      若使用者名称没有加上去，则代表切换为 root 的身份。
-l  ：与 - 类似，但后面需要加欲切换的使用者帐号！也是 login-shell 的方式。
-m  ：-m 与 -p 是一样的，表示“使用目前的环境设置，而不读取新使用者的配置文件”
-c  ：仅进行一次命令，所以 -c 后面添加需要执行的命令！
```

切换到root用户时有两种方式：

- su：此方式切换时，将使用non-login的方式读取变量配置文件。所以此方式**不推荐**
- su - ：此方式切换时会使用login-shell的方式读取变量配置文件。**推荐**使用此方式切换用户

切换成一般用户时：

```bash
#切换到xbx用户
su -l xbx
#无法切换到该用户，因为该用户的shell为/sbin/nologin
su -l sshd
```

****

**sudo**

相对于su切换用户的方法来使用root命令，sudo可以在其他用户的身份下使用root命令。

sudo命令可以使用当前账号以任何身份执行命令：

- -b：后面接欲切换的用户，若无此项则表示切换至root身份

```bash
#以root身份执行命令
sudo less /etc/shadow
#通过将当前账号切换至sshd，使用sshd的身份执行touch命令。
sudo -u sshd touch /tmp/mysshd
```

**sudo的执行过程**

1. 当使用者执行 sudo 时，系统于 /etc/sudoers 文件中搜寻该使用者是否有执行 sudo 的权限；
2. 若使用者具有可执行 sudo 的权限后，便让使用者“输入使用者自己的密码”来确认；
3. 若密码输入成功，便开始进行 sudo 后续接的指令（但 root 执行 sudo 时，不需要输入密码）；
4. 若欲切换的身份与执行者身份相同，那也不需要输入密码。

记录用户是否具有执行sudo权限的文件为/etc/sudoers。该文件记录用户是否使用sudo命令的各种限制，可以对其进行设置来调整用户的sudo使用。但是不可以直接修改该文件，应使用visudo命令来修改该文件。应使用root身份执行该命令。

## 特殊的shell，/sbin/nologin

当某些用户不允许登录系统时，可以将该账号设置的使用shell中设置为/sbin/nologin。这样这个账号就无法登录系统。

## PAM简介

PAM是一套程序接口，他提供了一些验证机制，用户有验证需求时调用PAM，然后PAM将验证的结果进行返回。

## 查询用户

可以使用w或who命令查看当前主机上登录的用户等信息。

```bash
[root@study ~]# w
 01:49:18 up 25 days,  3:34,  3 users,  load average: 0.00, 0.01, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
dmtsai   tty2                      07Jul15 12days  0.03s  0.03s -bash
dmtsai   pts/0    172.16.200.254   00:18    6.00s  0.31s  0.11s sshd: dmtsai [priv]
# 第一行显示目前的时间、开机 （up） 多久，几个使用者在系统上平均负载等；
# 第二行只是各个项目的说明，
# 第三行以后，每行代表一个使用者。如上所示，dmtsai 登陆并取得终端机名 tty2 之意。

[root@study ~]# who
dmtsai   tty2         2015-07-07 23:07
dmtsai   pts/0        2015-07-22 00:18 （192.168.1.100）
```

通过`lastlog`命令可以查看用户的最后登录时间。

# 例行性工作

系统在运行时常常需要做一些重复性的工作，比如重建locate数据库，删除临时文件等工作。往往这些工作很无无聊，人去做的话浪费时间浪费精力。所以交给机器去做，通过设置一个时间或执行间隔指定机器去做这件事。

主要有两个命令：

- at：仅执行依次的命令
- crontab：每隔一定周期就执行一次的命令

## 仅执行一次的工作调度

at命令可以设置仅执行一次的工作，通过给命令设置指定的时间，让工作在指定时间执行。

at命令依赖atd服务，只有atd服务启动时才可以使用at命令。

```bash
#重启atd服务
/etc/init.d/atd restart
#设置开机启动atd服务
chkconfig atd on
```

----

**at的运行方式**

- at命令可以理解为产生两部分内容，一个是要工作的内容，一个是将工作排在日程表中。要工作的内容在执行完at命令后会保存在/var/spool/at/目录下。保存的内容就是一个shell脚本。
- 并不是每个用户都可以执行at命令。可以通过/etc/at.allow 与 /etc/at.deny这两个文件指定可以执行at命令的用户。
  - 先找寻 **/etc/at.allow** 这个文件，写在这个文件中的使用者才能使用 at ，没有在这个文件中的使用者则不能使用 at （即使没有写在 at.deny 当中）；
  - 如果 /etc/at.allow 不存在，就寻找 **/etc/at.deny** 这个文件，若写在这个 at.deny 的使用者则不能使用 at ，而没有在这个 at.deny 文件中的使用者，就可以使用 at 咯；
  - 如果两个文件都不存在，那么只有 root 可以使用 at 这个指令。
- 通常只存在一个空的/etc/at.deny文件，此时表示所有用户都可以执行at命令。

---

**使用at命令**

```shell
[root@study ~]# at [-mldv] TIME
[root@study ~]# at -c 工作号码
选项与参数：
-m  ：当 at 的工作完成后，即使没有输出信息，也可以 email 通知使用者该工作已完成。
-l  ：at -l 相当于 atq，列出目前系统上面的所有该使用者的 at 调度；
-d  ：at -d 相当于 atrm ，可以取消一个在 at 调度中的工作；
-v  ：可以使用较明显的时间格式列出 at 调度中的工作列表；
-c  ：可以列出后面接的该项工作的实际指令内容。

TIME：时间格式，这里可以定义出“什么时候要进行 at 这项工作”的时间，格式有：
  HH:MM                ex&gt; 04:00
    在今日的 HH:MM 时刻进行，若该时刻已超过，则明天的 HH:MM 进行此工作。
  HH:MM YYYY-MM-DD        ex&gt; 04:00 2015-07-30
    强制规定在某年某月的某一天的特殊时刻进行该工作！
  HH:MM[am&#124;pm] [Month] [Date]    ex&gt; 04pm July 30
    也是一样，强制在某年某月某日的某时刻进行！
  HH:MM[am&#124;pm] + number [minutes&#124;hours&#124;days&#124;weeks]
    ex&gt; now + 5 minutes    ex&gt; 04pm + 3 days
    就是说，在某个时间点“再加几个时间后”才进行。
```

```shell
#5分钟后新建一个helo.sh文件，以ctrl+d结束输入
[xbx@instance-8 ~]$ at now + 5minutes
at> touch helo.sh
at> <EOT>
job 3 at 2019-06-22 15:36
```

****

**at工作运行过程**

以at命令定义的任务，在执行时会进入at shell环境执行任务。并不是在当前用户所在的shell环境中，所以当任务输出信息时不会显示在屏幕上。

任务执行时会先将目录切换至定义任务的文件夹也就是使用at命令的文件夹。

****

**at相关命令**

- atq：查询当前主机上有多少at任务
- atrm：通过任务编号删除任务
- batch：设置任务，不过以此命令设置的任务只有在系统cpu负载低的时候才会执行。其设置方式与at相同

## 循环执行的例行性工作

使用crontab命令可以设置如每天固定几点，每隔多久执行一次的任务。

该命令由cron这个系统服务控制。与at一样，可以通过/etc/cron.allow与/etc/cron.deny命令设置可以使用crontab命令的用户。

****

**crontab命令的使用**

一个用户只有一个crontab文件，所有的任务都定义在该文件中。

```
[root@study ~]# crontab [-u username] 
选项与参数：
-u  ：只有 root 才能进行这个任务，亦即帮其他使用者创建/移除 crontab 工作调度；
-e  ：编辑 crontab 的工作内容
-l  ：查阅 crontab 的工作内容
-r  ：移除所有的 crontab 的工作内容，若仅要移除一项，请用 -e 去编辑。
```

当需要删除一个cron任务时直接使用-e就可以。若要删除所有cron任务则需要使用-r

用户定义的任务都被保存在/var/spool/cron文件夹内，该文件夹内通过用户进行分类。cron执行的每次任务都会记录在/var/log/cron这个日志文件中

执行`crontab -e`编辑循环执行任务

```bash
#每天17点0分新建一个文件
0 17 * * * cd;touch hello.sh
```

编辑所用的格式与意义：



| 代表意义 | 分钟 | 小时 | 日期 | 月份 | 周   | 命令     |
| -------- | ---- | ---- | ---- | ---- | ---- | -------- |
| 数字范围 | 0-59 | 0-23 | 1-31 | 1-12 | 0-7  | 就命令啊 |



| 特殊字符   | 代表意义                                                     |
| ------------------ | ------------------------------------------------------------ |
| *（星号）  | 代表任何时刻都接受的意思！举例来说，范例一内那个日、月、周都是 * ， 就代表着“不论何月、何日的礼拜几的 12:00 都执行后续指令”的意思！ |
| ,（逗号）  | 代表分隔时段的意思。举例来说，如果要下达的工作是 3:00 与 6:00 时，就会是： `> 0 3,6 * * * command` 时间参数还是有五栏，不过第二栏是 3,6 ，代表 3 与 6 都适用！ |
| -（减号）  | 代表一段时间范围内，举例来说， 8 点到 12 点之间的每小时的 20 分都进行一项工作： `> 20 8-12 * * * command` 仔细看到第二栏变成 8-12 喔！代表 8,9,10,11,12 都适用的意思！ |
| /n（斜线） | 那个 n 代表数字，亦即是“每隔 n 单位间隔”的意思，例如每五分钟进行一次，则： `> */5 * * * * command` 很简单吧！用 * 与 /5 来搭配，也可以写成 0-59/5 ，相同意思！ |

## 系统的cron任务

系统也存在一些循环执行的任务，这些任务定义在/etc/crontab文件中。

该文件中定义任务的方式与定义个人的cron方式类似。不同的是定义系统的cron任务时文件前端有变量的定义，在定义任务的语句中可以设置任务执行的用户。

# 程序管理与SELinux

## 程序与进程

当执行一个存在于硬盘中的程序时，会将该程序读取到内存中成为一个个体，这就是进程。为了操作系统可以管理这个进程，进程将被赋予执行者的权限/属性等参数，并且将该进程所需要的代码与数据一同读入进程中。最后赋予一个PID。这个进程衍生出来的进程也会沿用该进程的权限。

**子进程与父进程**

当我们登录系统后会取得一个bash的shell，然后去执行别的命令如touch，ls等。在执行另外的这些命令时也会被赋予PID。在执行另外命令产生的进程就是子进程。其父进程就是bash的进程。

通过程序的PPID可以查看该进程的父进程。

当杀死一个进程后，过段时间又自动重启且PID号不同，此时应该杀掉其父进程再杀掉子进程。

```bash
#PPID为父进程的PID
[xbx@instance-8 ~]$ ps -l
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S   500 23167 23166  0  80   0 - 27134 do_wai pts/0    00:00:00 bash
0 S   500 29497 23167  0  80   0 - 27104 do_wai pts/0    00:00:00 bash
0 R   500 29862 29497  0  80   0 - 27039 -      pts/0    00:00:00 ps
```

****

**linux创建进程的方式**

进程会通过父进程以复制（fork）的方式产生一个一摸一样的子进程，然后被复制出来的子进程再以exec的方式执行要进程的进程，最终成为一个子进程的存在。

![](https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/img/fork-and-exec.gif)

****

**常驻在内存的进程**

有些进程并不是像ls，touch这类进程执行完就结束，而是一直都存在的。这些进程一直存在于内存中，也可以将这些进程称之为服务。

****

**linux的多用户、多任务环境**

在 Linux 下面执行一个指令时，系统会将相关的权限、属性、程序码与数据等均载入内存， 并给予这个单元一个程序识别码 （PID），最终该指令可以进行的任务则与这个 PID 的权限有关，这样就为每个用户形成一个独立的运行环境。

## 工作管理

假设我们只有一个终端，可以出现提示符并让你操作的成为前台。其他的工作可以在后台中运行。

后台中运行的工作又分为‘暂停’与‘运行中’。

- 这些工作所触发的程序必须来自于你 shell 的子程序（只管理自己的 bash）；
- 前台：你可以控制与下达指令的这个环境称为前台的工作 （foreground）；
- 后台：可以自行运行的工作，你无法使用 [ctrl]+c 终止他，可使用 bg/fg 调用该工作；
- 后台中“执行”的程序不能等待 terminal/shell 的输入（input）

****

**将命令放到后台执行：&**

在命令后加上&符号后可以将该命令放在后台中运行。但是放在后台中运行的命令其输出也会输出到前台，所以一般会在命令后加上重定向，将标准输出与标准错误输出重定向到文件中。

```bash
#新建一个后台任务
[xbx@instance-8 ~]$ find / &>/dev/null &
[1] 30601
```

****

**将目前进行中的工作进行后台暂停：ctrl+z**

将正在前台运行的工作加入到后台中并暂停，使用ctrl+z组合键。

```bash
#将vi hello 命令放入后台中
[xbx@instance-8 ~]$ vi hello
#返回的工作号后的+号，表示最近被加入到后台中的程序。使用fg拿到前台处理
[1]+  Stopped                 vim hello
```

****

**查看后台工作状态：jobs**

jobs命令可以查看，目前后台的工作状态。

```bash
[root@study ~]# jobs [-lrs]
-l  ：除了列出 job number 与指令串之外，同时列出 PID 的号码；
-r  ：仅列出正在后台运行的工作；
-s  ：仅列出正在后台当中暂停 （stop） 的工作。

范例一：观察目前的 bash 当中，所有的工作，与对应的 PID
[root@study ~]# jobs -l
[1]- 14566 Stopped                 vim ~/.bashrc
[2]+ 14567 Stopped                 find / -print
```

其实 + 代表最近被放到后台的工作号码， - 代表最近最后第二个被放置到后台中的工作号码。 而超过最后第三个以后的工作，就不会有 +/- 符号存在了！

****

**将后台工作拿到前台：fg**

fg命令默认取出带+号的任务，执行`fg -`可以取出带-号的任务。

```bash
[root@study ~]# fg %jobnumber
选项与参数：
%jobnumber ：jobnumber 为工作号码（数字）。注意，那个 % 是可有可无的！

范例一：先以 jobs 查看后台工作：
[root@study ~]# jobs -l
[1]- 14566 Stopped                 vim ~/.bashrc
[2]+ 14567 Stopped                 find / -print
[root@study ~]# fg ==默认取出那个 + 的工作，亦即 [2]。立即按下[ctrl]-z
```

****

**让工作在后台下由暂停变成运行：bg**

当使用ctrl+z将工作在后台暂停后可以使用bg命令将工作在后台由暂停变成运行状态。

```bash
#将3号任务由暂停变成运行状态
bg %3
```

****

**删除后台中的工作：kill**

```bash
[root@study ~]# kill -signal %jobnumber
[root@study ~]# kill -l
选项与参数：
-l  ：这个是 L 的小写，列出目前 kill 能够使用的讯号 （signal） 有哪些？
signal ：代表给予后面接的那个工作什么样的指示啰！用 man 7 signal 可知：
  -1 ：重新读取一次参数的配置文件 （类似 reload）；
  -2 ：代表与由键盘输入 [ctrl]-c 同样的动作；
  -9 ：立刻强制删除一个工作；
  -15：以正常的程序方式终止一项工作。与 -9 是不一样的
```

****

**脱机管理问题**

使用&符号只是防止使用ctrl+c终止命令，并不是将命令放在系统后台执行，还是和前台的shell有关。在连接断开后原来的使用&符号运行的后台命令就会中断掉。

可以使用at命令或nohup命令，将任务放在系统后台防止脱机带来的后台命令终止。

使用nohup与终端机没有关系了，他的输出信息被定向到~/nohup.out文件中。

```
[root@study ~]# nohup [指令与参数] 在终端机前端中工作
[root@study ~]# nohup [指令与参数] 在终端机后端中工作
```

## 进程管理

### 进程查看

查看linux进程可以使用ps命令和top命令。前者显示的是某一时刻的进程状态。后者是动态查看进程。

**ps**

ps的一些参数

```bash
    -a  显示所有终端机下执行的进程，除了阶段作业领导者之外。
　　 a  显示现行终端机下的所有进程，包括其他用户的进程。
　　-A  显示所有进程。
　　-c  显示CLS和PRI栏位。
　　 c  列出进程时，显示每个进程真正的指令名称，而不包含路径，参数或常驻服务的标示。
　　-C<指令名称> 　指定执行指令的名称，并列出该指令的进程的状况。
　　-d 　显示所有进程，但不包括阶段作业领导者的进程。
　　-e 　此参数的效果和指定"A"参数相同。
　　 e 　列出进程时，显示每个进程所使用的环境变量。
　　-f 　显示UID,PPIP,C与STIME栏位。
　　 f 　用ASCII字符显示树状结构，表达进程间的相互关系。
　　-g<群组名称> 　此参数的效果和指定"-G"参数相同，当亦能使用阶段作业领导者的名称来指定。
　　 g 　显示现行终端机下的所有进程，包括群组领导者的进程。
　　-G<群组识别码> 　列出属于该群组的进程的状况，也可使用群组名称来指定。
　　 h 　不显示标题列。
　　-H 　显示树状结构，表示进程间的相互关系。
　　-j或j 　采用工作控制的格式显示进程状况。
　　-l或l 　采用详细的格式来显示进程状况。
　　 L 　列出栏位的相关信息。
　　-m或m 　显示所有的执行绪。
　　 n 　以数字来表示USER和WCHAN栏位。
　　-N 　显示所有的进程，除了执行ps指令终端机下的进程之外。
　　-p<进程识别码> 　指定进程识别码，并列出该进程的状况。
　 　p<进程识别码> 　此参数的效果和指定"-p"参数相同，只在列表格式方面稍有差异。
　　 r 　只列出现行终端机正在执行中的进程。
　　-s<阶段作业> 　指定阶段作业的进程识别码，并列出隶属该阶段作业的进程的状况。
　 　s 　采用进程信号的格式显示进程状况。
　　 S 　列出进程时，包括已中断的子进程资料。
　　-t<终端机编号> 　指定终端机编号，并列出属于该终端机的进程的状况。
　　 t<终端机编号> 　此参数的效果和指定"-t"参数相同，只在列表格式方面稍有差异。
　　-T 　显示现行终端机下的所有进程。
　　-u<用户识别码> 　此参数的效果和指定"-U"参数相同。
　　 u 　以用户为主的格式来显示进程状况。
　　-U<用户识别码> 　列出属于该用户的进程的状况，也可使用用户名称来指定。
　　 U<用户名称> 　列出属于该用户的进程的状况。
　　 v 　采用虚拟内存的格式显示进程状况。
　　-V或V 　显示版本信息。
　　-w或w 　采用宽阔的格式来显示进程状况。　
　 　x 　显示所有进程，不以终端机来区分。
　　 X 　采用旧式的Linux i386登陆格式显示进程状况。
　　 -y 配合参数"-l"使用时，不显示F(flag)栏位，并以RSS栏位取代ADDR栏位。
```

常用组合：

```bash
ps aux    查看系统的所有进程数据
ps -l     仅查看自己bash的相关进程
ps axjf   查看所有进程并以树形结构显示    pstree命令也可以显示进程树
```

**top**

top命令可以持续监测进程的运行状态。

```bash
[root@study ~]# top [-d 数字]; top [-bnp]
选项与参数：
-d  ：后面可以接秒数，就是整个程序画面更新的秒数。默认是 5 秒；
-b  ：以批次的方式执行 top ，还有更多的参数可以使用喔！
      通常会搭配数据流重导向来将批次的结果输出成为文件。
-n  ：与 -b 搭配，意义是，需要进行几次 top 的输出结果。
-p  ：指定某些个 PID 来进行观察监测。
在 top 执行过程当中可以使用的按键指令：
    ? ：显示在 top 当中可以输入的按键指令；
    P ：以 CPU 的使用资源排序显示；
    M ：以 Memory 的使用资源排序显示；
    N ：以 PID 来排序喔！
    T ：由该 Process 使用的 CPU 时间累积 （TIME+） 排序。
    k ：给予某个 PID 一个讯号（signal）。形似kill命令
    r ：给予某个 PID 重新制订一个 nice（与进程的执行优先级有关，越小越早执行） 值。
    q ：离开 top 软件的按键。
```

```bash
top -d 2    打开top每两秒更新一次界面
top -p 1    打开top，只显示PID为1的进程
top -b -n 2 > top.txt   将top执行两次top，将输出的内容输出到top.txt文件中
```

*****

**pstree**

以进程树的方式显示进程信息。

```
[root@study ~]# pstree [-up]
选项与参数：
-A  ：各程序树之间的连接以 ASCII 字符来连接；
-U  ：各程序树之间的连接以万国码的字符来连接。在某些终端接口下可能会有错误；
-p  ：并同时列出每个 process 的 PID；
-u  ：并同时列出每个 process 的所属帐号名称。
```

### 进程的管理

可以通过kill或killall命令来停止进程。区别在于kill只接收PID进行进程的管理，killall则可以使用启动某进程时使用的命令来进行进程的管理。

**kill命令**

kill命令格式：kill -信号 PID。

常用信号如下：

| 信号 | 名称    | 内容                                                         |
| ---- | ------- | ------------------------------------------------------------ |
| 1    | SIGHUP  | 启动被终止的程序，可让该 PID 重新读取自己的配置文件，类似重新启动 |
| 2    | SIGINT  | 相当于用键盘输入 [ctrl]-c 来中断一个程序的进行               |
| 9    | SIGKILL | 代表强制中断一个程序的进行，如果该程序进行到一半， 那么尚未完成的部分可能会有“半产品”产生，类似 vim会有 .filename.swp 保留下来。 |
| 15   | SIGTERM | 以正常的结束程序来终止该程序。由于是正常的终止， 所以后续的动作会将他完成。不过，如果该程序已经发生问题，就是无法使用正常的方法终止时， 输入这个 signal 也是没有用的。 |
| 19   | SIGSTOP | 相当于用键盘输入 [ctrl]-z 来暂停一个程序的进行               |

**killall 命令**

与kill只能对一个进程进行管理不同，killall可以管理通过指定命令产生的所有进程。

```
[root@study ~]# killall [-iIe] [command name]
选项与参数：
-i  ：interactive 的意思，互动式的，若需要删除时，会出现提示字符给使用者；
-e  ：exact 的意思，表示“后面接的 command name 要一致”，但整个完整的指令
      不能超过 15 个字符。
-I  ：指令名称（可能含参数）忽略大小写。
```

如：

```bash
find /    使用ctrl+z暂停后
killall -9 find /    停止所有find /为启动命令的进程
```

### 进程的执行顺序

进程使用CPU的优先级由priority（top命令中的PR值）和nice（top命令中的NI值）值决定。这两个值越小，对应的进程就执行优先级就越高。PR值由操作系统决定，用户无法更改。所以调整进程优先级时只能调整NI值。

PR（新）=PR（老）+NI

所以将NI值调低就可以提高进程的优先级。NI值的范围为：-20~19。

在执行命令时执行NI值使用nice命令。更改正在执行的命令的NI值使用renice命令。

```bash
[root@study ~]# nice [-n 数字] command
选项与参数：
-n  ：后面接一个数值，数值的范围 -20 ~ 19。

范例一：用 root 给一个 nice 值为 -5 ，用于执行 vim .
[root@study ~]# nice -n -5 vim &
```

```bash
[root@study ~]# renice [number] PID
选项与参数：
PID ：某个程序的 ID 
```

修改了父进程的nice值后，该进程新建的子线程也将继承该nice值。

## 查看系统资源

**free：查看内存使用情况**

free命令：直接输入free显示的是以KB为单位的。可以添加-m，-g,-b等参数设置显示单位为MB，GB，B。

****

**uname：查看系统与内核相关信息**

```bash
[root@study ~]# uname [-asrmpi]
选项与参数：
-a  ：所有系统相关的信息，包括下面的数据都会被列出来；
-s  ：系统内核名称
-r  ：内核的版本
-m  ：本系统的硬件名称，例如 i686 或 x86_64 等；
-p  ：CPU 的类型，与 -m 类似，只是显示的是 CPU 的类型！
-i  ：硬件的平台 （ix86）
```

****

**uptime：系统启动时间与负载**

该命令可以显示系统开机时间，用户数，平均负载等信息

****

**netstat：跟踪网络**

单独使用netstat命令的输出包括两部分，网络部分和进程间通信部分。

```bash
[root@study ~]# netstat -[atunlp]
选项与参数：
-a  ：将目前系统上所有的连线、监听、Socket 数据都列出来
-t  ：列出 tcp 网络的数据
-u  ：列出 udp 网络的数据
-n  ：不以程序的服务名称，以端口号 （port number） 来显示；
-l  ：列出目前正在网络监听 （listen） 的服务；
-p  ：列出该网络服务的程序 PID
```

常用组合：

````bash
netstat -tlnp     显示所有正在建通状态中的tcp网络，显示端口与PID
````

****

**vmstat：检测系统资源变化**

该命令显示系统的内存，cpu等资源的使用情况。

```
选项与参数：
-a  ：使用 inactive/active（活跃与否） 取代 buffer/cache 的内存输出信息；
-f  ：开机到目前为止，系统复制 （fork） 的程序数；
-s  ：将一些事件 （开机至目前为止） 导致的内存变化情况列表说明；
-S  ：后面可以接单位，让显示的数据有单位。例如 K/M 取代 Bytes 的容量；
-d  ：列出磁盘的读写总量统计表
-p  ：后面列出分区，可显示该分区的读写总量统计表
```

## SELinux

**简介**

SELinux  == “ Security Enhanced Linux ”安全强化的意思。

SELinux 是由美国国家安全局 （NSA） 开发的，当初开发这玩意儿的目的是因为很多企业界发现， 通常系统出现问题的原因大部分都在于“内部员工的资源误用”所导致的，实际由外部发动的攻击反而没有这么严重。举例来说，如果将网页所在目录 /var/www/html/ 的权限设置为 drwxrwxrwx 时，这样该网络软件就会获得这个软件的写权限，如果有坏人利用这个漏洞，瞎几把乱写就不好了。所以美国佬的国家安全局就开始研究这个问题，当时需要找个系统做实验，而Linux又是免费的还好用所以就选了它。

SELinux 对和文件另外设置一个字段作为独立于原来的rwx这样的权限做权限控制。有空再研究吧。

安装www服务器时访问目录当设置在home目录下时将无法访问。就是SELinux搞的事情。

# 系统服务简介

## daemon与服务

daemon是“守护神，恶魔”。在linux中是守护进程的意思。

系统为了实现某些功能必须要提供一些服务，这个服务就称为service。但是这个service运行需要进程来运行，所以实现这个service的程序就称为daemon。

## daemon与主要分类

- stand-alone：这个daemon可以自行单独启动服务。这种类型的daemon可以自行启动而不必通过其他机制进行管理。这种daemon启动后一直存在于内存中持续的提供服务，因此对于发生客户端的请求，stand-alone类型的daemon响应速度快。
- super-daemon：由一个特殊的daemon来同意管理。这一类服务是通过一个统一的daemon来负责唤起服务，这个特殊的daemon就被成为super daemon。super daemon是一个叫做xinetd的程序。这种机制的意思为：当没有客户端请求时，各项服务都是未启动状态，等到由请求时，super daemon才会被唤醒。这样可以节约系统的资源。由于super daemon负责唤醒各项服务，所以super daemon具有安全控管的机制，类似于防火墙。

## centos7之前的启动方式

centos7之前将所有的启动文件放在/etc/init.d文件夹下。通过脚本进行直接启动。

### daemon的启动脚本与启动方式

daemon启动时不仅仅是运行一个程序而已，daemon的启动还需要执行文件、配置文件、执行唤醒等。一般在启动daemon的脚本中都将这些进行了配置。

通常一个daemon启动时，就会在/var/run目录下创建一个文件，用来记录该daemon的PID。

****

**daemon启动脚本的放置位置**

- /etc/init.d/*：系统中几乎所有服务的启动脚本都放置在这里。
- /etc/sysconfig/*：各服务的初始化环境配置文件
- /etc/xinit.conf   /etc.xinetd.d/* :super daemon配置文件。/etc/xinit.conf 默认配置文件。
- /etc/*：各个服务的配置文件
- /var/lib/*:各个服务产生的数据库
- /var/run/*：各服务的程序的PID的记录处

****

**Stand-alone的/etc/init.d/*启动**

几乎系统中所有服务的启动脚本都在/etc/init.d中。这里面的文件回去检测环境，查找配置文件，加载环境函数等功能。所以可以通过直接运行该文件夹下的脚本文件启动服务。

```bash
# 直接运行脚本可以查看使用方法与可用参数
[xbx@instance-8 xinetd.d]$ /etc/init.d/sshd
/etc/init.d/sshd: line 33: /etc/sysconfig/sshd: Permission denied
Usage: /etc/init.d/sshd {start|stop|restart|reload|force-reload|condrestart|try-restart|status}
# 查看sshd服务的状态
[xbx@instance-8 xinetd.d]$ /etc/init.d/sshd status
/etc/init.d/sshd: line 33: /etc/sysconfig/sshd: Permission denied
openssh-daemon (pid  1672) is running...
# 重启sshd服务
[xbx@instance-8 xinetd.d]$ sudo /etc/init.d/sshd restart
Stopping sshd:                                             [  OK  ]
Starting sshd:                                             [  OK  ]
```

**通过service进程进行stand-alone进程的启动**

linux提供了一个名为service的进程来对stand-alone进程进行管理。通过service后的参数名称，然后到/etc/init.d文件夹下去查找要执行的程序

````bash
service --status-all     将系统中所有stand alone的服务状态都列举出来
service 要操作的服务名 要执行的指令
service sshd restart     重启sshd服务。同/etc/init.d/sshd restart命令
````

*****

**super daemon的启动方式**

其实super daemon本身也是一个stand alone服务。他会一直常驻内存中。他只是负责对一些daemon进行管理。其他的daemon通过配置文件进行设置是否启动，以及其他的启动设置信息。

super daemon的配置文件在鸟哥558页。

### 设置开机启动服务

linux在启动时会进入不同的模式。这模式我们称为执行等级，不同的执行等级有不同的功能与服务。当以窗口启动时等级为5，当以纯文本界面启动时等级为3。通过chkconfig命令可以查看各个启动等级下可以启动的服务。

**chkconfig：管理系统服务默认开机启动与否**

```**bash
chkconfig --list    查看系统的各个服务在每个启动模式下的自启情况
chkconfig 服务名 on/off   设置服务是否开机自启
chkconfig --level 启动等级  服务名 on/off   设置某服务在某个启动等级下的自启情况
sudo chkconfig --level 345 atd on     设置atd这个服务在启动等级345情况下自动启动
```

**使用chkconfig对自己编写的脚本进行管理：**

要设置自己的脚本为开机自启分为一下几步：

1. 将该脚本放在/etc/init.d文件夹下

2. 脚本中设置chkconfig，此字段设置启动等级与启动顺序

3. 使用chkconfig --add命令将该程序加入chkconfig进行管理。 chkconfig --del命令取消chkconfig对该命令的管理

   ````bash
   # 在/etc/init.d/文件夹下添加脚本
   #!/bin/bash
   #chkconfig: 35 80 70      # 设置系统等级与启动顺序
   echo "hello world!!!"
   
   # 将该脚本添加到chkconfig管理
   sudo chkconfig --add test
   
   # 取消管理
   sudo chkconfig --del test
   ````

chkconfig可以对super daemon管理的程序设置是否自启。

*****

**ntsysv：图型界面对自启服务进行管理**

在命令行中直接输入ntsysv即可打开管理界面。

## centos7的启动方式

centos7之后采用通过systemd程序进行对daemon的管理，所有的daemon启动、停止等功能都通过systemctl命令进行操作。采用systemd对daemon进行管理还具有以下优点：

1. 平行处理所有服务，加速开机流程
2. 一个systemctl命令代替之前的init、chkconfig、service等命令
3. 服务之间依赖性自我检查
4. 对daemno进行分类

### systemd配置相关目录

- /usr/lib/systemd/system/： 使用 CentOS 官方提供的软件安装后，默认的启动脚本配置文件都放在这里，这里的数据尽量不要修改～ 要修改时，请到 /etc/systemd/system 下面修改较佳！
- /run/systemd/system/： 系统执行过程中所产生的服务脚本，这些脚本的优先序要比 /usr/lib/systemd/system/ 高！
- /etc/systemd/system/： 管理员依据主机系统的需求所创建的执行脚本，其实这个目录有点像以前 /etc/rc.d/rc5.d/Sxx 之类的功能！执行优先序又比 /run/systemd/system/ 高喔！
- /etc/sysconfig/*： 几乎所有的服务都会将初始化的一些选项设置写入到这个目录下，举例来说，mandb 所要更新的 man page 索引中，需要加入的参数就写入到此目录下的 man-db 当中喔！而网络的设置则写在 /etc/sysconfig/network-scripts/ 这个目录内。所以，这个目录内的文件也是挺重要的；
- /var/lib/： 一些会产生数据的服务都会将他的数据写入到 /var/lib/ 目录中。举例来说，数据库管理系统 Mariadb 的数据库默认就是写入 /var/lib/mysql/ 这个目录下啦！
- /run/： 放置了好多 daemon 的暂存盘，包括 lock file 以及 PID file 等等。

### systemd的服务类型分类

根据/usr/lib/systemd/system/下文件的扩展名可以看出来systemd的分类情况。

| 扩展名            | 主要服务功能                                                 |
| ----------------- | ------------------------------------------------------------ |
| .service          | 一般服务类型 （service unit）：主要是系统服务，包括服务器本身所需要的本机服务以及网络服务都是！比较经常被使用到的服务大多是这种类型！ 所以，这也是最常见的类型了！ |
| .socket           | 内部程序数据交换的插槽服务 （socket unit）：主要是 IPC （Inter-process communication） 的传输讯息插槽档 （socket file） 功能。 这种类型的服务通常在监控讯息传递的插槽档，当有通过此插槽档传递讯息来说要链接服务时，就依据当时的状态将该用户的要求传送到对应的 daemon， 若 daemon 尚未启动，则启动该 daemon 后再传送用户的要求。使用 socket 类型的服务一般是比较不会被用到的服务，因此在开机时通常会稍微延迟启动的时间 （因为比较没有这么常用嘛！）。一般用于本机服务比较多，例如我们的图形界面很多的软件都是通过 socket 来进行本机程序数据交换的行为。 （这与早期的 xinetd 这个 super daemon 有部份的相似喔！） |
| .target           | 执行环境类型 （target unit）：其实是一群 unit 的集合，例如上面表格中谈到的 multi-user.target 其实就是一堆服务的集合～也就是说， 选择执行 multi-user.target 就是执行一堆其他 .service 或/及 .socket 之类的服务就是了！ |
| .mount .automount | 文件系统挂载相关的服务 （automount unit / mount unit）：例如来自网络的自动挂载、NFS 文件系统挂载等与文件系统相关性较高的程序管理。 |
| .path             | 侦测特定文件或目录类型 （path unit）：某些服务需要侦测某些特定的目录来提供伫列服务，例如最常见的打印服务，就是通过侦测打印伫列目录来启动打印功能！ 这时就得要 .path 的服务类型支持了！ |
| .timer            | 循环执行的服务 （timer unit）：这个东西有点类似 anacrontab 喔！不过是由 systemd 主动提供的，比 anacrontab 更加有弹性！ |

### 通过systemctl管理服务

systemctl常用命令参数：

```
[root@study ~]# systemctl [command] [unit]
command 主要有：
start     ：立刻启动后面接的 unit
stop      ：立刻关闭后面接的 unit
restart   ：立刻关闭后启动后面接的 unit，亦即执行 stop 再 start 的意思
reload    ：不关闭后面接的 unit 的情况下，重新载入配置文件，让设置生效
enable    ：设置下次开机时，后面接的 unit 会被启动
disable   ：设置下次开机时，后面接的 unit 不会被启动
status    ：目前后面接的这个 unit 的状态，会列出有没有正在执行、开机默认执行否、登录等信息等！
is-active ：目前有没有正在运行中
is-enable ：开机时有没有默认要启用这个 unit
```

通过systemctl status 查看daemon状态：

```bash
[xbx@instance-9 system]$ sudo systemctl status sshd
● sshd.service - OpenSSH server daemon
   Loaded: loaded (/usr/lib/systemd/system/sshd.service; enabled; vendor preset: enabled)
   Active: active (running) since Thu 2019-06-27 05:30:02 UTC; 3 days ago
     Docs: man:sshd(8)
           man:sshd_config(5)
 Main PID: 2999 (sshd)
   CGroup: /system.slice/sshd.service
           └─2999 /usr/sbin/sshd -D

Jul 01 02:24:09 instance-9 sshd[9478]: Disconnected from 159.65.242.16 port 57264 [preauth]
Jul 01 02:26:11 instance-9 sshd[9557]: Invalid user smbprint from 106.13.38.59 port 19200
Jul 01 02:26:11 instance-9 sshd[9557]: input_userauth_request: invalid user smbprint [preauth]
```

该指令可以查看某个daemon的状态信息，包括现在的运行状态与默认状态：

上面输出结果的第三行就是现在状态：

- active （running）：正有一只或多只程序正在系统中执行的意思，举例来说，正在执行中的 vsftpd 就是这种模式。
- active （exited）：仅执行一次就正常结束的服务，目前并没有任何程序在系统中执行。 举例来说，开机或者是挂载时才会进行一次的 quotaon 功能，就是这种模式！ quotaon 不须一直执行～只须执行一次之后，就交给文件系统去自行处理啰！通常用 bash shell 写的小型服务，大多是属于这种类型 （无须常驻内存）。
- active （waiting）：正在执行当中，不过还再等待其他的事件才能继续处理。举例来说，打印的伫列相关服务就是这种状态！ 虽然正在启动中，不过，也需要真的有伫列进来 （打印工作） 这样他才会继续唤醒打印机服务来进行下一步打印的功能。
- inactive：这个服务目前没有运行的意思。

上面输出结果的第二行就包含daemon的默认状态：

- enabled：这个 daemon 将在开机时被执行
- disabled：这个 daemon 在开机时不会被执行
- static：这个 daemon 不可以自己启动 （enable 不可），不过可能会被其他的 enabled 的服务来唤醒 （相依属性的服务）
- mask：这个 daemon 无论如何都无法被启动！因为已经被强制注销 （非删除）。可通过 systemctl unmask 方式改回原本状态

### 通过systemctl观察系统中的所有服务

systemctl可以查看系统中的所有服务以及状态

```bash
[root@study ~]# systemctl [command] [--type=TYPE] [--all]
command:
    list-units      ：依据 unit 列出目前有启动的 unit。若加上 --all 才会列出没启动的。
    list-unit-files ：依据 /usr/lib/systemd/system/ 内的文件，将所有文件列表说明。
--type=TYPE：就是之前提到的 unit type，主要有 service, socket, target 等

例一：列出系统上面有启动的 unit。systemctl不加参数默认就是systemctl list-units的意思
[root@study ~]# systemctl
# 字段的主要的意义是：
# UNIT   ：项目的名称，包括各个 unit 的类别 （看扩展名）
# LOAD   ：开机时是否会被载入，默认 systemctl 显示的是有载入的项目而已喔！
# ACTIVE ：目前的状态，须与后续的 SUB 搭配！就是我们用 systemctl status 观察时，active 的项目！
# DESCRIPTION ：详细描述啰

例二：列出所有已经安装的 unit。显示文件名与默认状态
[root@study ~]# systemctl list-unit-files
UNIT FILE                                   STATE
proc-sys-fs-binfmt_misc.automount           static
```

### systemctl对service类型的配置文件

**systemctl配置文件目录简介**

systemd 的配置文件大部分放置于 /usr/lib/systemd/system/ 目录内。但是 Red Hat 官方文件指出， 该目录的文件主要是原本软件所提供的设置，建议不要修改！而要修改的位置应该放置于 /etc/systemd/system/ 目录内。举例来说，如果你想要额外修改 vsftpd.service 的话， 他们建议要放置到哪些地方呢？

- /usr/lib/systemd/system/vsftpd.service：官方释出的默认配置文件；
- /etc/systemd/system/vsftpd.service.d/custom.conf：在 /etc/systemd/system 下面创建与配置文件相同文件名的目录，但是要加上 .d 的扩展名。然后在该目录下创建配置文件即可。另外，配置文件最好附文件名取名为 .conf 较佳！ 在这个目录下的文件会“累加其他设置”进入 /usr/lib/systemd/system/vsftpd.service 内喔！
- /etc/systemd/system/vsftpd.service.wants/*：此目录内的文件为链接文件，设置相依服务的链接。意思是启动了 vsftpd.service 之后，最好再加上这目录下面建议的服务。
- /etc/systemd/system/vsftpd.service.requires/*：此目录内的文件为链接文件，设置相依服务的链接。意思是在启动 vsftpd.service 之前，需要事先启动哪些服务的意思。

**service配置文件内容简介**

配置文件分为三个部份：

- [Unit]： unit 本身的说明，以及与其他相依 daemon 的设置，包括在什么服务之后才启动此 unit 之类的设置值；
- [Service], [Socket], [Timer], [Mount], [Path]..：不同的 unit type 就得要使用相对应的设置项目。我们拿的是 sshd.service 来当范本，所以这边就使用 [Service] 来设置。 这个项目内主要在规范服务启动的脚本、环境配置文件文件名、重新启动的方式等等。
- [Install]：这个项目就是将此 unit 安装到哪个 target 里面去的意思！

每部分的内容：

| [Unit] 部份   |                                                              |
| ------------- | ------------------------------------------------------------ |
| 设置参数      | 参数意义说明                                                 |
| Description   | 就是当我们使用 systemctl list-units 时，会输出给管理员看的简易说明！当然，使用 systemctl status 输出的此服务的说明，也是这个项目！ |
| Documentation | 这个项目在提供管理员能够进行进一步的文件查询的功能！提供的文件可以是如下的数据：`Documentation=http://www....` `Documentation=man:sshd（8）``Documentation=file:/etc/ssh/sshd_config` |
| After         | 说明此 unit 是在哪个 daemon 启动之后才启动的意思！基本上仅是说明服务启动的顺序而已，并没有强制要求里头的服务一定要启动后此 unit 才能启动。 以 sshd.service 的内容为例，该文件提到 After 后面有 network.target 以及 sshd-keygen.service，但是若这两个 unit 没有启动而强制启动 sshd.service 的话， 那么 sshd.service 应该还是能够启动的！这与 Requires 的设置是有差异的喔！ |
| Before        | 与 After 的意义相反，是在什么服务启动前最好启动这个服务的意思。不过这仅是规范服务启动的顺序，并非强制要求的意思。 |
| Requires      | 明确的定义此 unit 需要在哪个 daemon 启动后才能够启动！就是设置相依服务啦！如果在此项设置的前导服务没有启动，那么此 unit 就不会被启动！ |
| Wants         | 与 Requires 刚好相反，规范的是这个 unit 之后最好还要启动什么服务比较好的意思！不过，并没有明确的规范就是了！主要的目的是希望创建让使用者比较好操作的环境。 因此，这个 Wants 后面接的服务如果没有启动，其实不会影响到这个 unit 本身！ |
| Conflicts     | 代表冲突的服务！亦即这个项目后面接的服务如果有启动，那么我们这个 unit 本身就不能启动！我们 unit 有启动，则此项目后的服务就不能启动！ 反正就是冲突性的检查啦！ |



| [Service] 部份  |                                                              |
| --------------- | ------------------------------------------------------------ |
| 设置参数        | 参数意义说明                                                 |
| Type            | 说明这个 daemon 启动的方式，会影响到 ExecStart 喔！一般来说，有下面几种类型 simple：默认值，这个 daemon 主要由 ExecStart 接的指令串来启动，启动后常驻于内存中。forking：由 ExecStart 启动的程序通过 spawns 延伸出其他子程序来作为此 daemon 的主要服务。原生的父程序在启动结束后就会终止运行。 传统的 unit 服务大多属于这种项目，例如 httpd 这个 WWW 服务，当 httpd 的程序因为运行过久因此即将终结了，则 systemd 会再重新生出另一个子程序持续运行后， 再将父程序删除。据说这样的性能比较好！！oneshot：与 simple 类似，不过这个程序在工作完毕后就结束了，不会常驻在内存中。dbus：与 simple 类似，但这个 daemon 必须要在取得一个 D-Bus 的名称后，才会继续运行！因此设置这个项目时，通常也要设置 BusName= 才行！idle：与 simple 类似，意思是，要执行这个 daemon 必须要所有的工作都顺利执行完毕后才会执行。这类的 daemon 通常是开机到最后才执行即可的服务！比较重要的项目大概是 simple, forking 与 oneshot 了！毕竟很多服务需要子程序 （forking），而有更多的动作只需要在开机的时候执行一次（oneshot），例如文件系统的检查与挂载啊等等的。 |
| EnvironmentFile | 可以指定启动脚本的环境配置文件！例如 sshd.service 的配置文件写入到 /etc/sysconfig/sshd 当中！你也可以使用 Environment= 后面接多个不同的 Shell 变量来给予设置！ |
| ExecStart       | 就是实际执行此 daemon 的指令或脚本程序。你也可以使用 ExecStartPre （之前） 以及 ExecStartPost （之后） 两个设置项目来在实际启动服务前，进行额外的指令行为。 但是你得要特别注意的是，指令串仅接受“指令 参数 参数...”的格式，不能接受 <, >, >>, \|, & 等特殊字符，很多的 bash 语法也不支持喔！ 所以，要使用这些特殊的字符时，最好直接写入到指令脚本里面去！不过，上述的语法也不是完全不能用，亦即，若要支持比较完整的 bash 语法，那你得要使用 Type=oneshot 才行喔！ 其他的 Type 才不能支持这些字符。 |
| ExecStop        | 与 systemctl stop 的执行有关，关闭此服务时所进行的指令。     |
| ExecReload      | 与 systemctl reload 有关的指令行为                           |
| Restart         | 当设置 Restart=1 时，则当此 daemon 服务终止后，会再次的启动此服务。举例来说，如果你在 tty2 使用文字界面登陆，操作完毕后登出，基本上，这个时候 tty2 就已经结束服务了。 但是你会看到屏幕又立刻产生一个新的 tty2 的登陆画面等待你的登陆！那就是 Restart 的功能！除非使用 systemctl 强制将此服务关闭，否则这个服务会源源不绝的一直重复产生！ |
| RemainAfterExit | 当设置为 RemainAfterExit=1 时，则当这个 daemon 所属的所有程序都终止之后，此服务会再尝试启动。这对于 Type=oneshot 的服务很有帮助！ |
| TimeoutSec      | 若这个服务在启动或者是关闭时，因为某些缘故导致无法顺利“正常启动或正常结束”的情况下，则我们要等多久才进入“强制结束”的状态！ |
| KillMode        | 可以是 process, control-group, none 的其中一种，如果是 process 则 daemon 终止时，只会终止主要的程序 （ExecStart 接的后面那串指令），如果是 control-group 时， 则由此 daemon 所产生的其他 control-group 的程序，也都会被关闭。如果是 none 的话，则没有程序会被关闭喔！ |
| RestartSec      | 与 Restart 有点相关性，如果这个服务被关闭，然后需要重新启动时，大概要 sleep 多少时间再重新启动的意思。默认是 100ms （毫秒）。 |



| [Install] 部份 |                                                              |
| -------------- | ------------------------------------------------------------ |
| 设置参数       | 参数意义说明                                                 |
| WantedBy       | 这个设置后面接的大部分是 *.target unit ！意思是，这个 unit 本身是附挂在哪一个 target unit 下面的！一般来说，大多的服务性质的 unit 都是附挂在 multi-user.target 下面！ |
| Also           | 当目前这个 unit 本身被 enable 时，Also 后面接的 unit 也请 enable 的意思！也就是具有相依性的服务可以写在这里呢！ |
| Alias          | 进行一个链接的别名的意思！当 systemctl enable 相关的服务时，则此服务会进行链接文件的创建！以 multi-user.target 为例，这个家伙是用来作为默认操作环境 default.target 的规划， 因此当你设置用成 default.target 时，这个 /etc/systemd/system/default.target 就会链接到 /usr/lib/systemd/system/multi-user.target 啰！ |

### systemctl针对timer的配置文件

使用systemd的timers.target可以替代crond进行定时任务的处理。

# 软件安装-通过源码的方式

通过下载软件的源代码，通过编译实现软件安装。分为一下步骤：

1. 下载软件源代码。通常下载的格式为tar.gz格式。这种格式就是tarball。因为软件源代码过大，通过打包压缩可以减少传输过程中的带宽占用。

2. 对下载后的代码解压到/usr/local/src文件夹中。通常自己安装的软件都放在/usr/local/文件夹中。

3. 加压后通常会包含一个configure文件，运行此文件生成Makefile文件。（通过gcc对软件源代码进行编译过于繁琐与复杂，所以使用一个叫make的软件，该软件可以自动对软件进行编译和安装。而configure文件则是软件厂商提供的来根据linux发行版信息自动生成Makefile文件的工具。）

4. configure文件执行结束后，使用make命令进行编译，使用make install进行软件的按装。

5. 安装后的软件的相关文件通常放在如下文件夹中：

   - /usr/local/etc

   - /usr/local/bin

   - /usr/local/lib

   - /usr/local/man

     或：

   - /usr/local/软件名/etc

   - /usr/local/软件名/bin

   - /usr/local/软件名/lib

   - /usr/local/软件名/man

6. 当要删除安装的软件时，只需删除安装软件目录即可。即/usr/local/软件名

# 软件安装通过RPM与YUM方式

## RPM

通过下载源码然后使用make工具进行编译与安装效率较慢。如果针对特定的硬件与系统版本进行编译，将编译的二进制文件进行打包。这就是RPM包。

可以通过rpm命令来对RPM包进行管理，RPM提供依赖检查，当使用RPM安装软件时可以对RPM数据库进行更新与检查，以确认依赖包是否都已经安装。

使用rpm进行安装的步骤：

1. 下载合适的rpm包
2. 通过rpm命令进行安装

使用rpm安装软件的位置：



|目录        | 简介|
| -------------- | ----------------------------------------- |
| /etc           | 一些配置文件放置的目录，例如 /etc/crontab |
| /usr/bin       | 一些可可执行文件案                        |
| /usr/lib       | 一些程序使用的动态函数库                  |
| /usr/share/doc | 一些基本的软件使用手册与说明文档          |
| /usr/share/man | 一些 man page 文件                        |

使用rpm进行安装的命令：

```
[root@study ~]# rpm -ivh package_name
选项与参数：
-i ：install 的意思
-v ：察看更细部的安装信息画面
-h ：以安装信息列显示安装进度
```

| rpm安装时常用参数 | 代表意义                                                     |
| ----------------- | ------------------------------------------------------------ |
| --nodeps          | 使用时机：当发生软件属性相依问题而无法安装，但你执意安装时 危险性： 软件会有相依性的原因是因为彼此会使用到对方的机制或功能，如果强制安装而不考虑软件的属性相依， 则可能会造成该软件的无法正常使用！ |
| --replacefiles    | 使用时机： 如果在安装的过程当中出现了“某个文件已经被安装在你的系统上面”的信息，又或许出现版本不合的讯息 （confilcting files） 时，可以使用这个参数来直接覆盖文件。危险性： 覆盖的动作是无法复原的！所以，你必须要很清楚的知道被覆盖的文件是真的可以被覆盖喔！否则会欲哭无泪！ |
| --replacepkgs     | 使用时机： 重新安装某个已经安装过的软件！如果你要安装一堆 RPM 软件文件时，可以使用 rpm -ivh *.rpm ，但若某些软件已经安装过了， 此时系统会出现“某软件已安装”的信息，导致无法继续安装。此时可使用这个选项来重复安装喔！ |
| --force           | 使用时机：这个参数其实就是 --replacefiles 与 --replacepkgs 的综合体！ |
| --test            | 使用时机： 想要测试一下该软件是否可以被安装到使用者的 Linux 环境当中，可找出是否有属性相依的问题。范例为： `rpm -ivh pkgname.i386.rpm --test` |
| --justdb          | 使用时机： 由于 RPM 数据库破损或者是某些缘故产生错误时，可使用这个选项来更新软件在数据库内的相关信息。 |
| --nosignature     | 使用时机： 想要略过数码签章的检查时，可以使用这个选项。      |
| --prefix 新路径   | 使用时机： 要将软件安装到其他非正规目录时。举例来说，你想要将某软件安装到 /usr/local 而非正规的 /bin, /etc 等目录， 就可以使用“ --prefix /usr/local ”来处理了。 |
| --noscripts       | 使用时机：不想让该软件在安装过程中自行执行某些系统指令。说明： RPM 的优点除了可以将文件放置到定位之外，还可以自动执行一些前置作业的指令，例如数据库的初始化。 如果你不想要让 RPM 帮你自动执行这一类型的指令，就加上他吧！ |

**使用rpm进行查询**

rpm查询的主要位置是 /var/lib/rpm/ 这个目录。

```
[root@study ~]# rpm -qa                              &lt;==已安装软件
[root@study ~]# rpm -q[licdR] 已安装的软件名称       &lt;==已安装软件
[root@study ~]# rpm -qf 存在于系统上面的某个文件名     &lt;==已安装软件
[root@study ~]# rpm -qp[licdR] 未安装的某个文件名称  &lt;==查阅RPM文件
选项与参数：
查询已安装软件的信息：
-q  ：仅查询，后面接的软件名称是否有安装；
-qa ：列出所有的，已经安装在本机 Linux 系统上面的所有软件名称；
-qi ：列出该软件的详细信息 （information），包含开发商、版本与说明等；
-ql ：列出该软件所有的文件与目录所在完整文件名 （list）；
-qc ：列出该软件的所有配置文件 （找出在 /etc/ 下面的文件名而已）
-qd ：列出该软件的所有说明文档 （找出与 man 有关的文件而已）
-qR ：列出与该软件有关的相依软件所含的文件 （Required 的意思）
-qf ：由后面接的文件名称，找出该文件属于哪一个已安装的软件；
-q --scripts：列出是否含有安装后需要执行的脚本档，可用以 debug 喔！
查询某个 RPM 文件内含有的信息：
-qp[icdlR]：注意 -qp 后面接的所有参数以上面的说明一致。但用途仅在于找出
        某个 RPM 文件内的信息，而非已安装的软件信息！注意！
```

**删除rpm管理的软件**

```
 # 使用rpm -e加软件名即可对软件进行卸载
 rpm -e 软件名
```

## YUM

yum会根据远程设置的软件仓库，来自动下载合适的 rpm包并进行安装。

**查询**

```
[root@study ~]# yum [option] [查询工作项目] [相关参数]
选项与参数：
[option]：主要的选项，包括有：
  -y ：当 yum 要等待使用者输入时，这个选项可以自动提供 yes 的回应；
  --installroot=/some/path ：将该软件安装在 /some/path 而不使用默认路径
[查询工作项目] [相关参数]：这方面的参数有：
  search  ：搜寻某个软件名称或者是描述 （description） 的重要关键字；
  list    ：列出目前 yum 所管理的所有的软件名称与版本，有点类似 rpm -qa；
  info    ：同上，不过有点类似 rpm -qai 的执行结果；
  provides：从文件去搜寻软件！类似 rpm -qf 的功能！
```

**下载安装**

```
[root@study ~]# yum [option] [安装与升级的工作项目] [相关参数]
选项与参数：
  install ：后面接要安装的软件！
  update  ：后面接要升级的软件，若要整个系统都升级，就直接 update 即可
```

**卸载软件**

```bash
[root@study ~]# yum remove 软件名
```

**升级软件**

````bash
yum -y update
升级所有包同时也升级软件和系统内核

yum -y upgrade
只升级所有包，不升级软件和系统内核
````

**群组功能**

```bash
[root@study ~]# yum [群组功能] [软件群组]
选项与参数：
   grouplist   ：列出所有可使用的“软件群组组”，例如 Development Tools 之类的；
   groupinfo   ：后面接 group_name，则可了解该 group 内含的所有软件名；
   groupinstall：这个好用！可以安装一整组的软件群组，相当的不错用！
   groupremove ：移除某个软件群组；
```



