---
title: 鸟哥Linux_笔记
author: XIA
categories:
  - Linux
tags:
  - Linux
date: 2019-06-07 14:21:59
---
# 计算机概论
- 在网络传输时，使用的是bit为单位 ，常见的传输单位Mbit/s。1Byte=8bit。所以当听到网速为8M/1M时，转换为文件容量常用单位Byte时，为1MB/s或128KB/s
- 计算机主板分为南桥和北桥。intel的芯片架构为：北桥负责连接速度较快的CPU、内存、显卡等部件。南桥则负责连接速度较慢的周边接口，包括硬盘、USB、网卡等。
- CPU的频率指的是CPU每秒可以进行的工作次数。如3.0GHz的频率，表示每秒可以进行3.0乘十的九次方次工作，每次工作进行少数指令的运行。不同CPU之间不能通过单纯比较频率来判断性能，因为每个CPU的微指令集不同，架构不同，每次频率处理的工作指令数目也不同。所以频率只能用来比较同款CPU
- CPU外频指与外部组件进行数据传输/运算时的速度。倍频指的是CPU内部用来加速工作性能的一个倍数，两者想乘便是CPU的工作频率。CPU超频主要指的是外频。

## 硬盘分区和磁盘分区

- 机械硬盘的盘片上每个扇区512bytes大小
- 在磁盘的第一个分区包含两部分组成：主引导区(MBR),可以安装引导加载程序的位置，446bytes。分区表，记录硬盘分区情况，64bytes。
- 所谓的分区就是对64字节的分区表进行设置而已
- 硬盘的默认分区表仅能写入四组分区信息，分区分为主分区和扩展分区，主分区+扩展分区只能有四个，这是硬盘决定的。扩展分区只能有一个，由操作系统决定。逻辑分区由扩展分区切割出来。扩展分区无法被格式化。
- 分区的单位是柱面

## 开机流程与主引导分区（MBR）

- CMOS：记录各项硬件参数且嵌入在主板上的储存器。BIOS：开机时计算机执行的第一个程序，也是写在主板上。
- 通过设置BIOS，设置启动的硬盘。然后计算机到该硬盘的第一个扇区找到MBR分区。此时BIOS的工作就完成了
- MBR中包含一个引导加载程序（Boot loader），该程序由操作系统安装时提供。可以用来读取操作系统的内核文件，当读取到操作系统内核文件时，该程序也就完成了任务。
- 引导加载程序一般包含三个功能：提供菜单，用户可以选择不同的开机选项，实现多重引导。载入内核文件，直接指向可开机的程序区来启动操作系统。转交给其他loader，将引导加载功能交给其他loader负责。
- 引导程序除了安装在MBR分区，还可以安装在每个分区的引导扇区。这就是多重引导。当引导程序指向另一个引导程序时，就实现了多重引导。

## 另一种引导方式（UEFI）

当使用GPT格式的硬盘时可以使用UEFI的引导方式，该方式是BIOS引导的进化版。

当硬盘格式为GPT时可以进行无限分区。当使用UFEI引导时装系统时，默认会创建一个ESP分区（UEFI的引导分区）里面会存放关于引导的相关文件。该分区为FAT32文件系统。

当进项双系统安装时引导分区都应设置为一个分区。在安装win与linux双系统时，关闭win的快速启动功能，否则启动电脑时默认进入win系统。

# 命令快捷键

命令行进行命令操作的快捷键：

- ctrl+左右键:在单词之间跳转
- ctrl+a:跳到本行的行首
- ctrl+e:跳到页尾
- Ctrl+u：删除当前光标前面的文字 （还有剪切功能）
- ctrl+k：删除当前光标后面的文字(还有剪切功能)
- Ctrl+L：进行清屏操作
- Ctrl+y:粘贴Ctrl+u或ctrl+k剪切的内容
- Ctrl+w:删除光标前面的单词的字符
- Alt – d ：由光标位置开始，往右删除单词。往行尾删

# 压缩命令

## 两种压缩格式

**.gz格式**

使用gzip压缩的文件，格式为.gz

- -c：将压缩信息输出在屏幕上
- -d：解压缩参数
- -v：在屏幕上显示原文件与压缩文件的压缩比信息

```bash
#对文件进行压缩,对test.sh进行压缩，压缩后原文件会自动删除
gzip test.sh
#解压缩，会自动删除原压缩文件
gzip -d test.sh.gzip
```

**.bz2格式**

bzip2进行压缩后的文件扩展名为.bz2。

- -c：将压缩过程的数据输出到屏幕

- -z：压缩的参数

- -d：解压缩

- -k：保留原文件

  ```bash
  #压缩文件，保留源文件。同`bzip2 -zk test.sh`。
  bzip2 -k test.sh
  ```

## tar

tar是一个打包工具

- -c：对文件进行打包或压缩

- -x：对文件进行解打包和解压缩

- -f：后面接要处理的文件名

- -j：以bzip2进行压缩或解压，扩展名：.bz2

- -z：以gzip进行解压或压缩,扩展名：.gz

- -v：在处理过程中显示处理文件的文件名

- -C：在进行解压缩时，指定要解压到的特定目录

  ```bash
  #对dir文件夹进行打包并以gzip进行压缩
  tar -cvzf dir.tar.gz dir
  #对dir.tar.gz进行解打包与解压缩，指定解压后的文件存储在myDir文件夹中
  tar -zxvf dir.tar.gz -C myDir
  ```

  

# vi & vim

## vi的三种模式

- 一般模式：打开vi默认的模式，该模式下可以移动光标，进行删除，复制，粘贴操作。
- 编辑模式：一般模式下按下i、I、o、O、a、A、r、R进入编辑模式，此模式下可以对内容进行编辑。
- 命令行模式：一般模式下输入：、/、？进入命令行模式。该模式下可以进行查找，保存，显示行号等操作。

## 常用按键

xxxx

## vim环境设置与记录

- 每次使用vim的记录都会被记录下来。这些信息将保存到~/.viminfo文件中

- vim的设置文件保存在/etc/vimrc文件中。但是不建议更改该文件，可以设置单用户的设置，新建~/.vimrc文件，并对vim进行设置。

- 常用设置：

  ```bash
  set nu  "开启行号显示"
  syntax on  "语法排错"
  set autoindent  "自动缩排"
  ```

  

# bash shell

## what?

shell是可以用来调用操作系统功能的一个软件，操作系统管理硬件。

使用shell也可以调用别的软件。

linux将可以使用的shell保存在/etc/shells文件中，当用户登录后根据/etc/passwd文件获取用户使用的shell

bash shell是linux默认的shell

## bash shell的功能

- 命令记忆功能：用户使用的命令可以记忆下来，通过上下键可以进行选择和查看。被使用过的命令记录在~/.bash_history文件内。但是该文件只是记录之前登录的命令，这次登录使用的命令则存储在内存中，只有注销系统时才会存储在~/.bash_history文件中。
- 命令与文件名补全功能：tab键的使用
- 设置别名
- 作业控制、前台、后台控制
- 程序脚本（shell script）

## 命令的执行

当命令过长时可以使用`\回车`进行换行

## 变量

### 变量的设置和显示

- 变量设置`name=xbx`。等号两边不可以包含空格，变量名只可以包含字母和数字，且不可以以数字开头

- 变量的内容若包含空格则使用单引号或双引号将其包裹起来，但是若引号中包含变量,单引号中原样输出，双引号中则取出变量中的内容后输出：

  ```bash
  name=xbx
  hi='hello $name'        输出：hello $name
  hi="hello $name"        输出：hello xbx
  ```
  
- 设置变量时使用`\特殊字符`进行转义

- 当变量中包含其他命令时可以使用反单引号或$(命令)

  ```bash
  version=`uname -r`
  version=$(uname -r)
  
  echo $version
  2.168-128.el5
  ```

- 对已经存在的变量进行增加内容时：

  ```bash
  PATH="$PATH":/home/bin
  ```

- 若该变量需要在子线程执行，则需要以export来使变量变成环境变量

  ```bash
  export PATH
  ```

- 取消某个变量时使用unset命令

  ```bash
  unset name
  ```

- 一般大写字符为系统默认变量，自行设置的变量可以使用小写字符（纯粹依据用户喜好）

### 常用变量及功能

env命令可以查看当前环境下的所有环境变量，常用环境变量如下：

- HOME:用户的主文件夹
- SHELL：目前环境使用的shell
- PATH：执行文件的查找路径，以`:`分隔

set命令可以查看当前环境下所有环境变量与自定义变量

- PS1：提示符设置
- $：本shell的PID，使用`echo $$`显示
- ？：上次执行命令的回传码，一般0为成功,使用`echo ?`显示

export：将自定义变量转换成环境变量。环境变量可以被子线程引用而自定义变量只能在当前bash环境中使用。使用时`export 变量名`即可

**为什么环境变量可以被子线程引用？**

当启动一个shell时，操作系统会分配一块内存给shell使用，此内存中的变量可以被子进程取用。若父进程使用export功能，可以让自定义变量写入上述内存中。当加载另一个shell（即启动子线程），子shell可以将父shell的环境变量所在的内存导入到自己的环境变量内存中。

### 变量的键盘读取、数组与声明（read、array、declare）

- 键盘读取：read

  使用read命令可以读取键盘输入:-p,设置提示信息。-t，设置等待时间。

  ```bash
  read -p "please keying your name: " -t 30 name
  ```

- 变量声明：declare/typeset

  - 这两个命令作用相同，都是声明变量类型。

  - 当不添加任何参数时列出所有变量，类似set命令。

  - bash的便量默认都是字符串类型

  - declare参数：-a，定义变量为数组。-i，声明变量为整数类型。-x，将后面的变量声明为环境变量。-r，设置变量为只读类型。

    ```bash
    declare -ix sum=100        声明变量sum为整数类型且为环境变量
    
    var[0]=xia                 声明数组与取用数组内的数据
    var[1]=bao
    var[2]=xin
    
    echo "${var[0]},${var[0]},${var[0]}" 
    ```
### 限制用户资源的ulimit

  用户在系统中能够使用的资源可以通过相关设置进行限制，如：开启的进程数，使用cpu的最大时间等。可以使用ulimit命令进行设置。

  该命令的一些参数：-a,后面不接参数列出所有限制信息。-f，可以创建的最大文件大小。-u，单一用户可以使用的最大进程。-t，可以使用的最大cpu时间。

### 变量内容的删除、替换和微调

  变量的内容可以通过相关的操作进行一些微调，可以查看鸟哥313页。

## bash shell的操作环境

### 登录与欢迎信息

用户登录后显示的信息存储在/etc/issue与/etc/motd中

### bash环境的配置文件

当我们登录到bash中时什么都没有操作怎么就会有一堆变量了呢？这就是由linux中的配置文件决定的。系统启动后会默认读取一些配置文件来为bash提供初始的变量与别名的设置。

**当用户登录系统后读取配置文件的顺序(login shell)：**

1. 首先读取系统整体的配置文件：/etc/profile。该配置文件主要设置了PATH、MAIL、HISTSIZE等内容，一般情况下不要对该文件进行修改。该文件会对一下文件进行调用来对系统进行设置：

   - 对/etc/profile.d/下的*.sh文件进行调用，这个目录下的文件对ll、ls、which等命令进行了别名设置。当需要对系统中的命令进行初始的别名设置时可以在该文件夹下新建sh文件进行设置。
   - /etc/inptrc：当用户有自定义输入按键功能时会设置`INPUT=/etc/inptrc`变量
   - /etc/sysconfig/i18n:决定bash使用何种语言

2. 当bash读取/etc/profile设置完整体环境后，接下来会读取个人设置文件。当读取个人配置文件时会对三个配置文件进行读取，读取时从上到下依次检索，只读取一个。~/.bash_profile、~/.bash_login、~/.profile。一般centos默认提供~/.bash_profile文件，该文件包含默认含有两个作用：

   - 读取~/.bashrc文件。该文件默认只有有一个功能：读取/etc/bashrc文件，/etc/bashrc设置用户的PS1变量。用户的个人设置可以在~/.bashrc文件中设置如：设置别名与变量等。
   - 进一步设置PATH变量，为该变量添加路径$HOME/bin文件夹。并设置PATH为环境变量。所以当执行文件位于$HOME/bin文件夹内时也可以在任意地方使用。

3. 其他的配置文件，这些配置文件和bash没有相关性但是会影响到bash的操作。

   - ~/.bash_history文件：当登录到bash后会将该文件中记录的历史命令记录加载到内存中
   - ~/.bash_logout文件：此文件记录了当注销bash后再帮我做的事情

**no-login shell 仅读取~/.bashrc文件**

### source命令使用

当某个环境配置文件发生改变时，可以通过`source 改变的文件`或`. 改变的文件`进行重新加载。这两种加载方式效果相同，后一种时前一种的简写。

###   bash默认组合键

​	ctrl+c   终止目前命令

​	ctrl+s   暂停屏幕输出

​	ctrl+q   恢复屏幕输出

​	ctrl+u    删除整行命令

​	ctrl+z     暂停目前命令

## 数据流重定向

**重定向**

重定向就是将原本输出到屏幕上的信息输出保存到文件中。重定向分为标准输出、标准错误输出、标准输入。

- 标准输入：代码为0，使用<或<<
- 标准输出：代码为1，使用>或>>
- 标准错误输出：代码为2，使用2>或2>>

`>`为覆盖输出，`>>`为累加输出

标准输出与标准错误输出的区别：当命令正常执行时输出的内容为标准输出，当命令有错误产生时输出的错误信息为标准错误输出。

   ```bash
#标准输出到find文件，错误标准输出到find2文件
find / > ~/find 2>find2
#当标准输出与标准错误输出都输出到同一个文件时
find / &> ~/find
   ```

**命令连接**

- 不考虑命令之间的相关性，使用`;`

  ```bash
  sync; sync; shutdown -r now
  ```

- 考虑命令的相关性`||与&&` ，原理为前一个命令执行完成后的回传码决定是否执行下一个命令。

  
  
  | 命令执行情况   | 说         明                                                |
  | -------------- | ------------------------------------------------------------ |
| `cmd1 && cmd2`   | 若cmd1执行完毕且正确执行（$?=0）,则开始执行cmd2<br>若cmd1执行完毕且为错误（$?!=0）,则cmd2不执行 |
  | `cmd1 ll cmd2` | 若cmd1执行完毕且正确执行（$?=0）,则cmd2不执行<br>若cmd1执行完毕且为错误（$?!=0）,则开始执行cmd2 |
  
  ```bash
  #验证是否存在该文件夹
  ls /tmp/xbx && echo 'exist' || echo  'not exist'
  ```

## 管道命令

使用管道符`|`连接命令时，可以将前一个命令的标准输出输入到下一个命令，使用管道操作符需要满足两个条件：

1. 管道符后的命令只会获取前一个命令的标准输出，无法获取标准错误输出
2. 管道符后的命令需要支持标准输入

### 选取命令（cut与grep）

**cut命令**

cut命令是用来切割字符串的，支持三个参数：

- -d，后接分隔符表示以什么符号为分割标志进行分割。
- -f，根据-d的分割结果，-f后跟数字表示取出结果的哪一段。
- -c，以字符为单位取出指定区间内的字符。

```bash
#以：为分隔符，取出第4段与第5段字符
echo $PATH | cut -d ':' -f 4,5
#取出$PATH中的第5-10个字符
echo $PATH | cut -c 5-10
```

**grep命令**

grep分析一行数据，若一行中有我们想要的数据则拿出此行。grep支持以下参数：

- -c：计算找到所要查找的字符串找到的次数
- -i：忽略大小写
- -n：顺便输出行号
- -v：反向选择，即显示没有所要查找字符串的那一行

```bash
#输出包含xbx的总行数
last | grep -c 'xbx'
```

### 排序命令（sort、wc、uniq）

**排序：sort**

该命令可以对内容进行排序，以行为单位。支持的参数：

- -f：忽略大小写

- -n：以纯数字方式进行排序，默认以字符的方式进行排序

- -r：反向排序

- -t：分隔符，默认以tab进行分隔

- -k：根据指定空间进行排序

  ```shell
  #对/etc/passwd中内容，以：为分割符，对第三块内容进行排序
  cat /etc/passwd | sort -t ':' -k 3
  ```

**去重：uniq**

对输入的内容，当出现相同的多行时，仅保留一行。支持参数：

- -i：忽略大小写

- -c：进行计数

  ```shell
  last | uniq -c
  ```

**统计：wc**

对输入内容的行数，字符，字数（单词）进行统计

- -i ：仅列出行

- -w：仅列出多少字

- -m：列出多少字符

  ```bash
  #依次列出行，字，字符
  [xbx@instance-8 ~]$ last | wc
       10      89     654
  
  ```

### 双向重定向

当需要将标准输出既要保存到文件中，又要输出到屏幕时可以使用tee命令进行双向重定向

```bash
#将last命令的结果既输出到屏幕上也重定向到lastLog文件中
last | tee lastLog
```

# Shell Script

## 什么是sehll script

shell script是可以在unix like系统中执行的脚本文件。执行方式：

- 通过`sh 脚本名`或`bash 脚本名`进行运行，/bin/sh是/bin/bash的链接文件，所以这两种方式执行是一样的。这种方式执行不需要为脚本赋予x权限。此方式在子线程中执行。

- 通过路径执行。通过绝对路径或相对路径执行。或使用PATH变量指定的路径直接执行。此种执行方式需要对脚本赋予x权限。此方式在子线程中执行。

- 通过`source命令`或`.`执行。这种方式执行时会在当前线程中执行。这也时为什么当修改变量配置文件时使用该命令可以在不注销系统的情况下重新加载变量配置文件。

  ```shell
  #指定该脚本使用的bash名称
  #!/bin/bash
  echo $PATH
  ```

## 测试判断

使用test命令可以进行判断，如判断文件是否存在，文件的权限信息，整数，字符串比较等功能。test后可接不通参数以进行不同的测试判断。

也可以通过中括号进行测试判断。注意中括号中的空格，`[ -e hello ] && echo 'yes' || echo 'no'`作用同test命令。

- -e：判断文件名是否存在
- -f：判断文件名是否为文件
- -d：判断文件名是否为目录
- -r/w/x：判断文件是否具有该权限
- 判断两个字符串是否相同时可以用=或者==
- 。。。。。。。。。鸟哥p380

```bash
#测试hello文件是否存在
test -e hello && echo 'yes' || echo 'no'
#判断name与name1变量的值是否相同，判断字符串时最好使用双引号包裹变量，防止变量内容含有空格
[ "$name" == "$name1" ] && echo 'yes' || echo 'no'
```

## 默认变量

当执行sh脚本时可以默认传入一些参数，就像执行java程序时的传入参数，不同的是java保存到数组，而sh保存到一些默认变量中。

- $#：代表后接的参数的个数
- $@：代表$1,$2等，对应从左到右传入的参数，$0代表命令本身
- $*：代表所有参数，以空格分开

```shell
#!/bin/bash
echo $0 $1 $2 $3
echo $#
echo $*
```

## if语句

语法：

```bash
#!/bin/bash

#多条件判断
if [ "$1" == "y" ] || [ "$1" == "Y" ]; then
        echo "yes"
fi

#elif 使用
if [ "$1" == "hello" ]; then
        echo "hello how are you ?"
elif [ "$1" == "" ]; then
        echo "not null"
else
        echo "only hello"
fi
```

## case语句

语法：

```bash
#!/bin/bash
case $1 in
        "one")
           echo "your choice is one"
           ;;
        "two")
           echo "your choice is two"
           ;;
        *)  #通配符
           echo "usage $0 {one|two|three}"
           ;;
esac
```

## function

- 函数定义要在使用之前
- 函数中可以访问内置变量，$0,$1,$2,$3。$0为函数名。其他为传入的参数值，函数中使用内置变量不会访问到shell脚本的内置变量

```bash
#!/bin/bash
#定义函数，由于sh脚本是从上到下，从左到右执行，所以定义要在使用之前
#function中可以访问变量，使用$1,$2。
function pname ( ) {
  echo "your choice is $1"
}

case $1 in
        "one")
          #调用函数 并进行传参
          pname 1
        ;;
        "two")
          pname 2
        ;;
        "three")
          pname 3
        ;;
        *)
          echo "{one|two|three}"
        ;;
esac
```

## while语句

语法：

```bash
#!/bin/bash
#求1+2+3+...+100的值
declare -i sum=0
declare -i i=1

while [ "$i" -le "100" ]
do
        sum=$sum+$i
        i=$i+1
done

echo $sum
```

## for语句

for...in 语句：对in后的结果进行循环，每次的结果存在in之前的变量中

```bash
#!/bin/bash
#循环输出1-100之间的数
for i in `seq 1 100`
do
        echo $i
done
```

for循环：

```bash
#!/bin/bash
for (( i=1; i<=100; i++ ))
do
        echo $i
done
```

## shell script的调试与追踪

在执行sh脚本时添加一些参数可以对脚本进行调试：

- -x：将使用到的sh内容显示到屏幕上
- -n：不执行脚本，仅检查语法错误
- -v：执行脚本前先将脚本内容输出到屏幕上

# 账号管理与ACL权限

## 用户标识符：UID、GID

linux中的每一个文件都至少会有两个id：UID和GID。分别用来标识该文件的所属用户和所属用户组。

当每个用户登录系统后，linux并不会认识你的登录名，他是根据/etc/passwd中的内容进行对应获取相应的用户UID，之后使用UID作为用户的标识符。

用户的用户组信息存储在/etc/group文件中。

## 用户账号

**用户登录流程：**

1. 先寻找/etc/passwd文件，验证是否包含此账号。没有则直接退出，有的话将该账号对应的UID与GID读出来，另外，该账号的主文件夹与shell设置也将一并读出来
2. 核对密码，此时linux会进入/etc/shadow文件中，找出该账号对应的密码进行核对
3. 通过以上两个阶段则进入shell的管控阶段

**/etc/passwd文件结构**

````bash
xbx:x:500:501::/home/xbx:/bin/bash
````

该文件每一行代表一个用户信息，通过`:`进行分割，共七个字段。依次为：账号名称，密码（已舍弃，现在存储在/etc/shadow内），UID（0为系统管理员，1-499为系统账号 ，500以后为可登录账号），GID，用户信息说明，主文件夹，Shell。

**/etc/shadow文件结构**

````bash
xbx:*:18063:0:99999:7:::
````

该文件存储账号的密码信息，同样以`:`进行分隔，共九个字段。分别为：账号名称，加密后的密码（密码前加！或*可以使密码失效），最近密码变更日期，密码不可变更天数，密码需要重新修改的天数，密码需要修改前的警告天数，密码过期后的账号宽限日期，账号失效日期，保留字段。

## 有效与初始用户组：groups，newgrp

用户的用户组信息存储在/etc/group文件内。当用户登录系统后在/etc/passwd内存储的GID信息对应到该文件。

**/etc/group文件结构**

````bash
video:x:39:xbx,xbx189651
````

每一行代表一个用户组，以分号进行分隔。共四列，分别为：用户组名称，用户组密码（一般为x），GID，此用户组支持的账号。当需要调整用户组中的用户时只需要修改该文件的最后一列，进行添加或删除用户即可。

**初始用户组**

一个用户可以同时存在于多个用户组。用户在/etc/passwd文件中保存的GID对应的用户组就是用户的初始用户组。当用户登录系统后默认使用的就是该用户组。

**有效用户组**

用户当前正在使用的用户组就是有效用户组。

可以使用`groups`命令进行查看该用户所支持的用户组。输出信息的第一个用户组便是有效用户组。

更改有效用户组可以使用`newgrp`命令。当切换有效用户组时实际上时打开了一个新的shell，在打开新shell时为该shell赋予所要切换到的用户组。

```bash
[xbx@instance-8 ~]$ groups            #查看支持的用户组
xbx adm video dip google-sudoers
[xbx@instance-8 ~]$ i=1               #设置临时变量
[xbx@instance-8 ~]$ echo $i           #验证
1
[xbx@instance-8 ~]$ newgrp adm        #切换用户组
[xbx@instance-8 ~]$ echo $i           #切换用户组后打开新的shell，原来的变量没有了

```

**/etc/gshadow文件结构**

```bash
adm:::adm,daemon,xbx,xbx189651
```

该文件主要用来设置用户组管理员使用，不过现在一般不设置这个玩意。该文件每行代表一个用户组，每行通过冒号分隔，共四个字段，分别为：用户组名，密码列（当午用户组管理员时，该项为！），用户组管理员账号，用户组的所属账号（与/etc/group相同）。

## 账号管理（增加、删除、修改）

**用户增加：useradd**

使用useradd命令可以增加用户。在增加用户是结合相应参数可以设置该用户的一些初始化信息。

```bash
[root@study ~]# useradd [-u UID] [-g 初始群组] [-G 次要群组] [-mM]\
&gt;  [-c 说明栏] [-d 主文件夹绝对路径] [-s shell] 使用者帐号名
选项与参数：
-u  ：后面接的是 UID ，是一组数字。直接指定一个特定的 UID 给这个帐号；
-g  ：后面接的那个群组名称就是我们上面提到的 initial group 啦～
      该群组的 GID 会被放置到 /etc/passwd 的第四个字段内。
-G  ：后面接的群组名称则是这个帐号还可以加入的群组。
      这个选项与参数会修改 /etc/group 内的相关数据喔！
-M  ：强制！不要创建使用者主文件夹！（系统帐号默认值）
-m  ：强制！要创建使用者主文件夹！（一般帐号默认值）
-c  ：这个就是 /etc/passwd 的第五栏的说明内容啦～可以随便我们设置的啦～
-d  ：指定某个目录成为主文件夹，而不要使用默认值。务必使用绝对路径！
-r  ：创建一个系统的帐号，这个帐号的 UID 会有限制 （参考 /etc/login.defs）
-s  ：后面接一个 shell ，若没有指定则默认是 /bin/bash 的啦～
-e  ：后面接一个日期，格式为“YYYY-MM-DD”此项目可写入 shadow 第八字段，
      亦即帐号失效日的设置项目啰；
-f  ：后面接 shadow 的第七字段项目，指定密码是否会失效。0为立刻失效，
      -1 为永远不失效（密码只会过期而强制于登陆时重新设置而已。）
```

创建用户时系统所作的工作：

- 在 /etc/passwd 里面创建一行与帐号相关的数据，包括创建 UID/GID/主文件夹等；
- 在 /etc/shadow 里面将此帐号的密码相关参数填入，但是尚未有密码；
- 在 /etc/group 里面加入一个与帐号名称一模一样的群组名称；
- 在 /home 下面创建一个与帐号同名的目录作为使用者主文件夹，且权限为 700

在新建用户时，默认的一些参数值如：默认用户组，默认主文件夹位置，默认shell等信息。这些信息都保存在/etc/default/useradd文件中。使用`useradd -D`可以查看新增用户时的默认设置。

新增用户的默认UID/GID的设置保存在/etc/login.defs中。

用户主目录内的内容的基准目录为/etc/skel。当新建用户时，系统会将该目录下的文件复制到新用户的主目录中。

------

**设置密码：passwd**

当使用了useradd命令新增用户后，并没有设置用户的登录密码。所以还需使用passwd命令为用户设置登录密码。

```bash
[root@study ~]# passwd [-l] [-u] [--stdin] [-S] \
&gt;  [-n 日数] [-x 日数] [-w 日数] [-i 日期] 帐号 &lt;==root 功能
选项与参数：
--stdin ：可以通过来自前一个管线的数据，作为密码输入，对 shell script 有帮助！
-l  ：是 Lock 的意思，会将 /etc/shadow 第二栏最前面加上 ! 使密码失效；
-u  ：与 -l 相对，是 Unlock 的意思！
-S  ：列出密码相关参数，亦即 shadow 文件内的大部分信息。
-n  ：后面接天数，shadow 的第 4 字段，多久不可修改密码天数
-x  ：后面接天数，shadow 的第 5 字段，多久内必须要更动密码
-w  ：后面接天数，shadow 的第 6 字段，密码过期前的警告天数
-i  ：后面接“日期”，shadow 的第 7 字段，密码失效日期
```

当root用户使用该命令时可以后面接账号名为指定账号设置密码。当普通用户使用该命令时可以为自己设置密码。

```bash
范例一：请 root 给予 vbird2 密码
[root@study ~]# passwd vbird2

范例二：用 vbird2 登陆后，修改 vbird2 自己的密码
[vbird2@study ~]$ passwd   &lt;==后面没有加帐号，就是改自己的密码！
```

可以通过`passwd -S`或`chage`命令查看密码设置的历史记录

----

**用户修改：usermod**

可以使用usermod命令对用户的信息进行修改，如修改主文件夹，初始用户组，次要用户组等。

```bash
[root@study ~]# usermod [-cdegGlsuLU] username
选项与参数：
-c  ：后面接帐号的说明，即 /etc/passwd 第五栏的说明栏，可以加入一些帐号的说明。
-d  ：后面接帐号的主文件夹，即修改 /etc/passwd 的第六栏；
-e  ：后面接日期，格式是 YYYY-MM-DD 也就是在 /etc/shadow 内的第八个字段数据啦！
-f  ：后面接天数，为 shadow 的第七字段。
-g  ：后面接初始群组，修改 /etc/passwd 的第四个字段，亦即是 GID 的字段！
-G  ：后面接次要群组，修改这个使用者能够支持的群组，修改的是 /etc/group 啰～
-a  ：与 -G 合用，可“增加次要群组的支持”而非“设置”喔！
-l  ：后面接帐号名称。亦即是修改帐号名称， /etc/passwd 的第一栏！
-s  ：后面接 Shell 的实际文件，例如 /bin/bash 或 /bin/csh 等等。
-u  ：后面接 UID 数字啦！即 /etc/passwd 第三栏的数据；
-L  ：暂时将使用者的密码冻结，让他无法登陆。其实仅改 /etc/shadow 的密码栏。
-U  ：将 /etc/shadow 密码栏的 ! 拿掉，解冻啦！
```

----

**用户删除：userdel**

当需要对用户进行删除时使用userdel命令。删除时删除的数据有：

- 使用者帐号/密码相关参数：/etc/passwd, /etc/shadow
- 使用者群组相关参数：/etc/group, /etc/gshadow
- 使用者个人文件数据： /home/username, /var/spool/mail/username..

```bash
#删除用户名为xbx的用户，-r表示一同删除用户的主文件夹
userdel -r xbx
```

## 用户组管理（增加、删除、修改）

**新增用户组：groupadd**

```bash
[root@study ~]# groupadd [-g gid] [-r] 用户组名称
选项与参数：
-g  ：后面接某个特定的 GID ，为新建的用户组指定GID
-r  ：新建系统用户组。与 /etc/login.defs 内的 GID_MIN 有关。
```

**修改用户组：groupmod**

```bash
[root@study ~]# groupmod [-g gid] [-n group_name] 用户组名
选项与参数：
-g  ：修改GID；
-n  ：修改用户组名称
```

**删除用户组：groupdel**

```bash
[root@study ~]# groupdel [groupname]
```

只有当被删除的用户组下没有用户时，用户组才可以被删除。

## ACL

什么是ACL：

ACL是Access Control List的缩写。他是一套独立的权限管理工具，它可以对文件夹，文件进行按用户，用户组进行权限的定义。

主要包含两个命令：getfacl和setfacl。分别为设置和获取acl权限。

## 用户身份切换

linux系统尽量使用一般账号进行登录操作，这样可以防止出现错误发生的情况。而且以较低的权限运行程序也比较安全，往往有时候某些软件也是不允许使用root账号进行运行，以减少软件被攻破带来的损失。

**su：切换用户**

su命令可以用来切换用户，如将一般账号切换到root账号（需要root密码），或将root账号切换到一般账号（不需要密码）。

```bash
[root@study ~]# su [-lm] [-c 指令] [username]
选项与参数：
-   ：单纯使用 - 如“ su - ”代表使用 login-shell 的变量文件读取方式来登陆系统；
      若使用者名称没有加上去，则代表切换为 root 的身份。
-l  ：与 - 类似，但后面需要加欲切换的使用者帐号！也是 login-shell 的方式。
-m  ：-m 与 -p 是一样的，表示“使用目前的环境设置，而不读取新使用者的配置文件”
-c  ：仅进行一次命令，所以 -c 后面添加需要执行的命令！
```

切换到root用户时有两种方式：

- su：此方式切换时，将使用non-login的方式读取变量配置文件。所以此方式**不推荐**
- su - ：此方式切换时会使用login-shell的方式读取变量配置文件。**推荐**使用此方式切换用户

切换成一般用户时：

```bash
#切换到xbx用户
su -l xbx
#无法切换到该用户，因为该用户的shell为/sbin/nologin
su -l sshd
```

****

**sudo**

相对于su切换用户的方法来使用root命令，sudo可以在其他用户的身份下使用root命令。

sudo命令可以使用当前账号以任何身份执行命令：

- -b：后面接欲切换的用户，若无此项则表示切换至root身份

```bash
#以root身份执行命令
sudo less /etc/shadow
#通过将当前账号切换至sshd，使用sshd的身份执行touch命令。
sudo -u sshd touch /tmp/mysshd
```

**sudo的执行过程**

1. 当使用者执行 sudo 时，系统于 /etc/sudoers 文件中搜寻该使用者是否有执行 sudo 的权限；
2. 若使用者具有可执行 sudo 的权限后，便让使用者“输入使用者自己的密码”来确认；
3. 若密码输入成功，便开始进行 sudo 后续接的指令（但 root 执行 sudo 时，不需要输入密码）；
4. 若欲切换的身份与执行者身份相同，那也不需要输入密码。

记录用户是否具有执行sudo权限的文件为/etc/sudoers。该文件记录用户是否使用sudo命令的各种限制，可以对其进行设置来调整用户的sudo使用。但是不可以直接修改该文件，应使用visudo命令来修改该文件。应使用root身份执行该命令。

## 特殊的shell，/sbin/nologin

当某些用户不允许登录系统时，可以将该账号设置的使用shell中设置为/sbin/nologin。这样这个账号就无法登录系统。

## PAM简介

PAM是一套程序接口，他提供了一些验证机制，用户有验证需求时调用PAM，然后PAM将验证的结果进行返回。

## 查询用户

可以使用w或who命令查看当前主机上登录的用户等信息。

```bash
[root@study ~]# w
 01:49:18 up 25 days,  3:34,  3 users,  load average: 0.00, 0.01, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
dmtsai   tty2                      07Jul15 12days  0.03s  0.03s -bash
dmtsai   pts/0    172.16.200.254   00:18    6.00s  0.31s  0.11s sshd: dmtsai [priv]
# 第一行显示目前的时间、开机 （up） 多久，几个使用者在系统上平均负载等；
# 第二行只是各个项目的说明，
# 第三行以后，每行代表一个使用者。如上所示，dmtsai 登陆并取得终端机名 tty2 之意。

[root@study ~]# who
dmtsai   tty2         2015-07-07 23:07
dmtsai   pts/0        2015-07-22 00:18 （192.168.1.100）
```

通过`lastlog`命令可以查看用户的最后登录时间。

# 例行性工作

系统在运行时常常需要做一些重复性的工作，比如重建locate数据库，删除临时文件等工作。往往这些工作很无无聊，人去做的话浪费时间浪费精力。所以交给机器去做，通过设置一个时间或执行间隔指定机器去做这件事。

主要有两个命令：

- at：仅执行依次的命令
- crontab：每隔一定周期就执行一次的命令

## 仅执行一次的工作调度

at命令可以设置仅执行一次的工作，通过给命令设置指定的时间，让工作在指定时间执行。

at命令依赖atd服务，只有atd服务启动时才可以使用at命令。

```bash
#重启atd服务
/etc/init.d/atd restart
#设置开机启动atd服务
chkconfig atd on
```

----

**at的运行方式**

- at命令可以理解为产生两部分内容，一个是要工作的内容，一个是将工作排在日程表中。要工作的内容在执行完at命令后会保存在/var/spool/at/目录下。保存的内容就是一个shell脚本。
- 并不是每个用户都可以执行at命令。可以通过/etc/at.allow 与 /etc/at.deny这两个文件指定可以执行at命令的用户。
  - 先找寻 **/etc/at.allow** 这个文件，写在这个文件中的使用者才能使用 at ，没有在这个文件中的使用者则不能使用 at （即使没有写在 at.deny 当中）；
  - 如果 /etc/at.allow 不存在，就寻找 **/etc/at.deny** 这个文件，若写在这个 at.deny 的使用者则不能使用 at ，而没有在这个 at.deny 文件中的使用者，就可以使用 at 咯；
  - 如果两个文件都不存在，那么只有 root 可以使用 at 这个指令。
- 通常只存在一个空的/etc/at.deny文件，此时表示所有用户都可以执行at命令。

---

**使用at命令**

```shell
[root@study ~]# at [-mldv] TIME
[root@study ~]# at -c 工作号码
选项与参数：
-m  ：当 at 的工作完成后，即使没有输出信息，也可以 email 通知使用者该工作已完成。
-l  ：at -l 相当于 atq，列出目前系统上面的所有该使用者的 at 调度；
-d  ：at -d 相当于 atrm ，可以取消一个在 at 调度中的工作；
-v  ：可以使用较明显的时间格式列出 at 调度中的工作列表；
-c  ：可以列出后面接的该项工作的实际指令内容。

TIME：时间格式，这里可以定义出“什么时候要进行 at 这项工作”的时间，格式有：
  HH:MM                ex&gt; 04:00
    在今日的 HH:MM 时刻进行，若该时刻已超过，则明天的 HH:MM 进行此工作。
  HH:MM YYYY-MM-DD        ex&gt; 04:00 2015-07-30
    强制规定在某年某月的某一天的特殊时刻进行该工作！
  HH:MM[am&#124;pm] [Month] [Date]    ex&gt; 04pm July 30
    也是一样，强制在某年某月某日的某时刻进行！
  HH:MM[am&#124;pm] + number [minutes&#124;hours&#124;days&#124;weeks]
    ex&gt; now + 5 minutes    ex&gt; 04pm + 3 days
    就是说，在某个时间点“再加几个时间后”才进行。
```

```shell
#5分钟后新建一个helo.sh文件，以ctrl+d结束输入
[xbx@instance-8 ~]$ at now + 5minutes
at> touch helo.sh
at> <EOT>
job 3 at 2019-06-22 15:36
```

****

**at工作运行过程**

以at命令定义的任务，在执行时会进入at shell环境执行任务。并不是在当前用户所在的shell环境中，所以当任务输出信息时不会显示在屏幕上。

任务执行时会先将目录切换至定义任务的文件夹也就是使用at命令的文件夹。

****

**at相关命令**

- atq：查询当前主机上有多少at任务
- atrm：通过任务编号删除任务
- batch：设置任务，不过以此命令设置的任务只有在系统cpu负载低的时候才会执行。其设置方式与at相同

## 循环执行的例行性工作

使用crontab命令可以设置如每天固定几点，每隔多久执行一次的任务。

该命令由cron这个系统服务控制。与at一样，可以通过/etc/cron.allow与/etc/cron.deny命令设置可以使用crontab命令的用户。

****

**crontab命令的使用**

一个用户只有一个crontab文件，所有的任务都定义在该文件中。

```
[root@study ~]# crontab [-u username] 
选项与参数：
-u  ：只有 root 才能进行这个任务，亦即帮其他使用者创建/移除 crontab 工作调度；
-e  ：编辑 crontab 的工作内容
-l  ：查阅 crontab 的工作内容
-r  ：移除所有的 crontab 的工作内容，若仅要移除一项，请用 -e 去编辑。
```

当需要删除一个cron任务时直接使用-e就可以。若要删除所有cron任务则需要使用-r

用户定义的任务都被保存在/var/spool/cron文件夹内，该文件夹内通过用户进行分类。cron执行的每次任务都会记录在/var/log/cron这个日志文件中

执行`crontab -e`编辑循环执行任务

```bash
#每天17点0分新建一个文件
0 17 * * * cd;touch hello.sh
```

编辑所用的格式与意义：



| 代表意义 | 分钟 | 小时 | 日期 | 月份 | 周   | 命令     |
| -------- | ---- | ---- | ---- | ---- | ---- | -------- |
| 数字范围 | 0-59 | 0-23 | 1-31 | 1-12 | 0-7  | 就命令啊 |



| 特殊字符   | 代表意义                                                     |
| ------------------ | ------------------------------------------------------------ |
| *（星号）  | 代表任何时刻都接受的意思！举例来说，范例一内那个日、月、周都是 * ， 就代表着“不论何月、何日的礼拜几的 12:00 都执行后续指令”的意思！ |
| ,（逗号）  | 代表分隔时段的意思。举例来说，如果要下达的工作是 3:00 与 6:00 时，就会是： `> 0 3,6 * * * command` 时间参数还是有五栏，不过第二栏是 3,6 ，代表 3 与 6 都适用！ |
| -（减号）  | 代表一段时间范围内，举例来说， 8 点到 12 点之间的每小时的 20 分都进行一项工作： `> 20 8-12 * * * command` 仔细看到第二栏变成 8-12 喔！代表 8,9,10,11,12 都适用的意思！ |
| /n（斜线） | 那个 n 代表数字，亦即是“每隔 n 单位间隔”的意思，例如每五分钟进行一次，则： `> */5 * * * * command` 很简单吧！用 * 与 /5 来搭配，也可以写成 0-59/5 ，相同意思！ |

## 系统的cron任务

系统也存在一些循环执行的任务，这些任务定义在/etc/crontab文件中。

该文件中定义任务的方式与定义个人的cron方式类似。不同的是定义系统的cron任务时文件前端有变量的定义，在定义任务的语句中可以设置任务执行的用户。

# 程序管理与SELinux

## 程序与进程

当执行一个存在于硬盘中的程序时，会将该程序读取到内存中成为一个个体，这就是进程。为了操作系统可以管理这个进程，进程将被赋予执行者的权限/属性等参数，并且将该进程所需要的代码与数据一同读入进程中。最后赋予一个PID。这个进程衍生出来的进程也会沿用该进程的权限。

**子进程与父进程**

当我们登录系统后会取得一个bash的shell，然后去执行别的命令如touch，ls等。在执行另外的这些命令时也会被赋予PID。在执行另外命令产生的进程就是子进程。其父进程就是bash的进程。

通过程序的PPID可以查看该进程的父进程。

当杀死一个进程后，过段时间又自动重启且PID号不同，此时应该杀掉其父进程再杀掉子进程。

```bash
#PPID为父进程的PID
[xbx@instance-8 ~]$ ps -l
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S   500 23167 23166  0  80   0 - 27134 do_wai pts/0    00:00:00 bash
0 S   500 29497 23167  0  80   0 - 27104 do_wai pts/0    00:00:00 bash
0 R   500 29862 29497  0  80   0 - 27039 -      pts/0    00:00:00 ps
```

****

**linux创建进程的方式**

进程会通过父进程以复制（fork）的方式产生一个一摸一样的子进程，然后被复制出来的子进程再以exec的方式执行要进程的进程，最终成为一个子进程的存在。

![](https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/img/fork-and-exec.gif)

****

**常驻在内存的进程**

有些进程并不是像ls，touch这类进程执行完就结束，而是一直都存在的。这些进程一直存在于内存中，也可以将这些进程称之为服务。

****

**linux的多用户、多任务环境**

在 Linux 下面执行一个指令时，系统会将相关的权限、属性、程序码与数据等均载入内存， 并给予这个单元一个程序识别码 （PID），最终该指令可以进行的任务则与这个 PID 的权限有关，这样就为每个用户形成一个独立的运行环境。

## 工作管理

假设我们只有一个终端，可以出现提示符并让你操作的成为前台。其他的工作可以在后台中运行。

后台中运行的工作又分为‘暂停’与‘运行中’。

- 这些工作所触发的程序必须来自于你 shell 的子程序（只管理自己的 bash）；
- 前台：你可以控制与下达指令的这个环境称为前台的工作 （foreground）；
- 后台：可以自行运行的工作，你无法使用 [ctrl]+c 终止他，可使用 bg/fg 调用该工作；
- 后台中“执行”的程序不能等待 terminal/shell 的输入（input）

****

**将命令放到后台执行：&**

在命令后加上&符号后可以将该命令放在后台中运行。但是放在后台中运行的命令其输出也会输出到前台，所以一般会在命令后加上重定向，将标准输出与标准错误输出重定向到文件中。

```bash
#新建一个后台任务
[xbx@instance-8 ~]$ find / &>/dev/null &
[1] 30601
```

****

**将目前进行中的工作进行后台暂停：ctrl+z**

将正在前台运行的工作加入到后台中并暂停，使用ctrl+z组合键。

```bash
#将vi hello 命令放入后台中
[xbx@instance-8 ~]$ vi hello
#返回的工作号后的+号，表示最近被加入到后台中的程序。使用fg拿到前台处理
[1]+  Stopped                 vim hello
```

****

**查看后台工作状态：jobs**

jobs命令可以查看，目前后台的工作状态。

```bash
[root@study ~]# jobs [-lrs]
-l  ：除了列出 job number 与指令串之外，同时列出 PID 的号码；
-r  ：仅列出正在后台运行的工作；
-s  ：仅列出正在后台当中暂停 （stop） 的工作。

范例一：观察目前的 bash 当中，所有的工作，与对应的 PID
[root@study ~]# jobs -l
[1]- 14566 Stopped                 vim ~/.bashrc
[2]+ 14567 Stopped                 find / -print
```

其实 + 代表最近被放到后台的工作号码， - 代表最近最后第二个被放置到后台中的工作号码。 而超过最后第三个以后的工作，就不会有 +/- 符号存在了！

****

**将后台工作拿到前台：fg**

fg命令默认取出带+号的任务，执行`fg -`可以取出带-号的任务。

```bash
[root@study ~]# fg %jobnumber
选项与参数：
%jobnumber ：jobnumber 为工作号码（数字）。注意，那个 % 是可有可无的！

范例一：先以 jobs 查看后台工作：
[root@study ~]# jobs -l
[1]- 14566 Stopped                 vim ~/.bashrc
[2]+ 14567 Stopped                 find / -print
[root@study ~]# fg ==默认取出那个 + 的工作，亦即 [2]。立即按下[ctrl]-z
```

****

**让工作在后台下由暂停变成运行：bg**

当使用ctrl+z将工作在后台暂停后可以使用bg命令将工作在后台由暂停变成运行状态。

```bash
#将3号任务由暂停变成运行状态
bg %3
```

****

**删除后台中的工作：kill**

```bash
[root@study ~]# kill -signal %jobnumber
[root@study ~]# kill -l
选项与参数：
-l  ：这个是 L 的小写，列出目前 kill 能够使用的讯号 （signal） 有哪些？
signal ：代表给予后面接的那个工作什么样的指示啰！用 man 7 signal 可知：
  -1 ：重新读取一次参数的配置文件 （类似 reload）；
  -2 ：代表与由键盘输入 [ctrl]-c 同样的动作；
  -9 ：立刻强制删除一个工作；
  -15：以正常的程序方式终止一项工作。与 -9 是不一样的
```

****

**脱机管理问题**

使用&符号只是防止使用ctrl+c终止命令，并不是将命令放在系统后台执行，还是和前台的shell有关。在连接断开后原来的使用&符号运行的后台命令就会中断掉。

可以使用at命令或nohup命令，将任务放在系统后台防止脱机带来的后台命令终止。

使用nohup与终端机没有关系了，他的输出信息被定向到~/nohup.out文件中。

```
[root@study ~]# nohup [指令与参数] 在终端机前端中工作
[root@study ~]# nohup [指令与参数] 在终端机后端中工作
```







