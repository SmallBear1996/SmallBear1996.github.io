---
title: JVM
author: XIA
categories:
  - 后端
tags:
  - java
date: 2019-10-23 21:55:28
---

# 运行时数据区域

jdk8之后运行时数据区域采用如下的类型：

![](https://xbxblog.bj.bcebos.com/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png)

**程序计数器：**线程私有。可以看作当前线程所执行的字节码的行号指示器，因为java中的多线程是通过线程轮流切换并分配处理器执行时间来实现的，因此处理器为了在每次切换线程后能够回到正确执行的位置，所以每个线程都要有一个独立的程序计数器。如果当前执行的是一个java方法那么这个值是正在执行的字节码指令的地址，如果是Native方法则这个值为空。

**虚拟机栈：**线程私有。每个方法执行时会创建一个栈帧用来保存局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成的过程就对应着一个栈帧的入栈到出栈的过程。局部变量表存放着编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）和对象引用reference、returnAddress类型。此区域可以抛出StackOverflowError异常和OutOfMemoryError异常。

可以通过-Xss参数设置栈容量，当一个线程中的虚拟机栈被填满后就会抛出StackOverflowError异常，无论是方法调用栈的深度太大还是栈中的本地变量太多。

由于虚拟机栈是线程私有的，那么如果线程数量过多则会导致虚拟机内存被这些线程的虚拟机栈耗尽，此时就会发生OutOfMemoryError。出现OutOfMemoryError的方式：当循环创建线程，每个循环中进行死递归，虚拟机的内存将被这些线程的虚拟机栈耗尽最终发生OutOfMemoryError异常。这种情况下可以通过减少最大堆或者减少栈容量来换取更多线程。

*操作数栈*是个初始状态为空的桶式结构栈。在方法执行过程中， 会有各种指令往栈中写入和提取信息。JVM 的执行引擎是基于栈的执行引擎， 其中的栈指的就是操作栈。字节码指令集的定义都是基于栈类型的，栈的深度在方法元信息的 stack 属性中。

关于操作数栈可以参考简单的i++与++i执行的底层汇编指令区别，来理解操作数栈。

i++与++i：<https://www.cnblogs.com/czwbig/p/11127124.html>

*returnAddress类型*看参考1与参考2。

>returnAddress 类型的值是指向字节码的指针，不管是物理机还是虚拟机，运行时内存中的数据总归可分为两类：代码，数据。对于冯诺依曼结构的计算机，指令数据和数值数据都存储在内存中，而哈弗结构的计算机，将程序指令与数据分开存储。
>
>对于 JVM 来说，程序就是存储在方法区的字节码指令，而 returnAddress 类型的值就是指向特定指令内存地址的指针。
>
>JVM支持多线程，每个线程有自己的程序计数器（pc register），而 pc 中的值就是当前指令所在的内存地址，即 returnAddress 类型的数据，当线程执行 native 方法时，pc 中的值为 undefined。
>
>方法执行时有两种退出情况：
>
>1. 正常退出，即正常执行到任何方法的返回字节码指令，如 RETURN、IRETURN、ARETURN 等；
>2. 异常退出。
>
>无论何种退出情况，都将返回至方法当前被调用的位置。方法退出的过程相当于弹出当前栈帧，退出可能有三种方式：
>
>1. 返回值压入上层调用栈帧。
>2. 异常信息抛给能够处理的栈帧。
>3. PC计数器指向方法调用后的下一条指令。

> 动态链接：每个栈帧中包含一个在常量池中对当前方法的引用， 目的是支持方法调用过程的动态连接

**本地方法栈：**线程私有。作用与虚拟机栈类似，不同的是本地方法栈是为虚拟机使用到的Native方法服务。

**堆：**线程共享。该区域的目的是存放对象实例，所有的对象实例和数组都要在堆上分配内存。堆也是垃圾收集器管理的主要区域，因此也叫做GC堆。堆可以处于物理上不连续的内存空间，只要逻辑上连续即可。可以通过-Xmx和-Xms控制该区域的大小。该区域可以抛出OutOfMemoryError异常。

**方法区：**线程共享。用来存放被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。JDK8 之前，Hotspot 中方法区的实现是永久代（Perm），JDK8 开始使用元空间（Metaspace），以前永久代所有内容的字符串常量移至堆内存，其他内容移至元空间，元空间直接在本地内存分配。

为什么要使用元空间取代永久代的实现？

1.  字符串存在永久代中，容易出现性能问题和内存溢出。
2.  类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
3.  永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
4.  将 HotSpot 与 JRockit 合二为一。

运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段等信息外，还有一项信息是常量池。存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。运行时常量池相对于Class常量池具有动态性，并非只有预置在class常量池中的常量才会进入运行时常量池，运行期间也可以将新的常量放入池中，如String的intern()方法。

方法区可以抛出OutOfMemoryError异常。

**直接内存：**直接内存并不是jvm定义的内存区域，在jdk1.4以后新增的NIO类引入了一种基于管道与缓冲区的IO方式，可以通过Native函数直接分配直接内存，然后通过堆中的FirectByteBuffer对象作为这块内存的引用进行操作，可以在某些场景中可以显著提高性能。

<https://www.cnblogs.com/xing901022/p/5243657.html>

# 对象的创建

在语言层面上，对象的创建仅仅通过一个new关键字。在虚拟机中当遇到一条new指令，首先检查这个指令的参数是否是否能在常量池中定位到一个类的符号引用，并且检查这个类是否被加载、解析、初始化过。

当类经过加载检查后，接下来虚拟机将为新生对象分配内存。对象所需内存在类加载完成后便确定了，分配内存可以通过指针碰撞法和空闲列表法。在并发时还需要考虑线程安全的问题，一种是对分配内存空间的动作进行同步处理，一种是把内存分配动作按照线程划分在不同的空间之中进行，即每个线程在java堆中先分配一小块内存，称为本地线程分配缓冲（TLAB），哪个线程要分配内存，就在哪个线程的TLAB上分配，当TLAB用完再进行加锁分配新的TLAB。

分配内存后，将分配到的内存空间都初始化为零值，保证对象的实例字段再java代码中可以不赋值直接俄使用。

接下来jvm会对对象头进行设置，对象头中保存着对象是哪个类的实例、哈希码、GC分代信息等。

在上面工作完成后接下来就是执行<init>方法了。将对象按照程序员的意愿进行初始化。

### 对象的内存布局

对象在内存中可以分为3块区域：对象头、实例数据、对齐填充。

**对象头：**

包括两部分信息，一部分是存储对象自身的运行时数据，如哈希码、GC分代信息、锁标志等。这部分数据在32位和64位虚拟机中分别为32bit和64bit。但是它实际存储的信息已经超过32bit或64bit。所以采用了一种可以复用自己空间的结构，根据对象的状态这部分的数据代表的结构也不相同。

![对象头](https://xbxblog.bj.bcebos.com/%E5%AF%B9%E8%B1%A1%E5%A4%B4.jpg)

另一部分是类型指针，即执行类元数据的指针。类型指针不一定执行方法区的类的元数据信息，也有可能指向堆内的句柄访问对象。

如果对象是一个数组，则对象头中还有一部分用于保存数组长度。

**数据实例：**

保存对象的真正有效信息，也就是程序中定义的各种类型的字段内容。它受虚拟机分配策略参数的影响。

**对齐填充：**

对齐填充不是必然的，只是起着占位的作用。

# 垃圾收集机制

## 谁是垃圾

进行垃圾收集的第一步就是需要判断一个对象是不是垃圾，通常有两种方法：引用计数法和可达性分析算法。

引用计数法无法解决对象间循环依赖的问题，一般很少使用。

可达性分析算法通过一系列的“GC Roots”作为起点，从这些节点向下搜索所走过的路径叫做引用链，当一个对象到GC Roots没有任何引用链相连时就表明该对象不可达，可以作为垃圾。

可以作为GC Roots的对象：

* 虚拟机栈中引用的对象
* 方法区静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI引用的对象

## 四种引用

在jdk1.2之前对引用的定义非常笼统，在jdk1.2之后在原有的引用概念之上进行了扩充，将引用分为了强引用、软引用、弱引用、虚引用。

+ 强引用：类似`Object obj = new Object()`,只要有强引用的存在，垃圾收集器就不会回收掉被引用的对象。
+ 软引用：用来描述还有用但是并非必须的对象。在即将发生内存溢出之前，将会对这些对象进行二次回收，如果回收之后还没有足够内存才会抛出内存溢出异常。SoftReference类表示软引用。
+ 弱引用：被弱引用关联的对象只能生存到下一次垃圾收集之前。WeakReference类表示弱引用。
+ 虚引用：最弱的一种引用，无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是在这个对象被收集之前可以收到一个系统通知。PhantomReference类表示虚引用。

## finalize()

真正对一个对象进行垃圾收集至少要进行两次标记过程，如果对象在进行第一次可达性分析后发现没有与GC Roots相连接，那么将会被第一次标记并且进行一次筛选，筛选条件为此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()或finalize()已经被虚拟机调用过则表示没有必要执行。

当对象被判断为有必要执行finalize()方法，那么这个对象将会放置在一个队列中，在一个虚拟机创建的低优先级线程中执行。finalize()方法并不保证能够执行完成。

finalize()是一个对象最后逃脱死亡的机会，可以在finalize()方法中与GC Roots相连来逃脱第二次标记过程。

## 垃圾回收算法

### 标记-清除法

该算法分为标记和清除两个阶段，首先标记出 需要回收的对象，标记完成后统一回收所有标记对象。该方法存在两个问题：效率低和空间碎片过多。

![1571758503791](https://xbxblog.bj.bcebos.com/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4.png)

### 复制算法

复制算法是为了解决效率问题而产生的，思路是将内存划分为两部分，每次只使用一部分，在进行垃圾收集时将正在使用的内存上的存活对象复制到另一部分未使用的内存中，然后将已经使用过的内存一次性清理。

但是两块内存的划分比例是个问题，IBM研究在java中新生成的对象98%是朝生夕死的。在现在虚拟机中通常将内存划分为一块Eden空间和两块Survivor空间，HotSpot中比例默认为8:1。也就是每次新生代可用容量为90%。

### 标记-整理算法

用于老年代垃圾的收集。类似于标记-清除算法，不同的是在标记之后会将存活的对象移动至一端，然后清除掉端边界以外的空间。

### 分代收集算法

按照对象存活周期的不同将内存分为新生代和老年代，然后根据每个内存区的特点选择不同的收集算法。在新生代中对象多是“朝生夕死”类型的，使用复制算法。在老年代中对象的存活率高且没有额外的空间进行分配担保，使用标记-清除算法或标记-整理算法。

## HotSpot的算法实现

准确式GC、安全点、安全区域



# 参考：

> 1. 深入理解 JVM 中的 returnAddress：<https://blog.csdn.net/antony1776/article/details/89843145>
>
> 2. Java内存区域（运行时数据区域）和内存模型（JMM）:<https://www.cnblogs.com/czwbig/p/11127124.html>