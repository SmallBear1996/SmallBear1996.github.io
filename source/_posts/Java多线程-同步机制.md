---
title: Java多线程-同步机制
author: XIA
categories:
  - 多线程
tags:
  - null
date: 2019-02-29 21:29:36
---

# 同步机制简介

前面说了线程安全的主要表现为：原子性、可见性、有序性。靠什么来保证他们呢，就是线程同步机制了，包括锁、volatile、final、static以及一些相关api等。

# 锁

 线程安全问题的产生前提是多个线程并发访问共享数据造成的，如果将对共享数据的访问由并发改为串行那么就不会存在线程安全问题了。这就是锁的思路。

通过使用一个对象，将这个对象作为锁，这个锁会锁住一组数据的操作，当一个线程需要访问操作对这组数据的操作时，需要获得这个锁才可以。

一个线程在访问共享数据前需要申请锁，在共享数据访问完成后会释放锁，在锁获取和释放之间的这段代码被称作临界区。锁具有排他性，同一时刻只可以由一个线程持有。

锁可以保障原子性、可见性、有序性。通过锁的互斥性保障原子性，很容易理解，同一时刻只可以由一个线程获得锁，这样就保证了通过一个时刻只有一个线程可以操作被保护的共享数据，这样其他的线程只能等待锁的释放后获取，这样在其他线程看来，此时的操作就是原子性的，因为他们没有锁可以看到中间结果。

线程在获取和释放锁的时候都会对处理器缓存进行刷新，这样锁就保障了可见性。将锁所保障的可见性和原子性结合起来，就可以保证临界区代码可以读取到共享数据的最新值。

由于锁对原子性和可见性的保障，锁就对有序性进行了保障。比如有一段代码`a=1;b=2;c=true`通过锁进行同步，那么段代码的执行结果在内存方面的反应是同时的，同时将a的内存赋值为1，b的内存赋值为2，c的内存赋值为true。都同时可就没有先后顺序了，所以有序性也保障了。当然并不是临界区的代码不会进行重排序，临界区的代码重排序只会在临界区以内进行，临界区内的代码不会与临界区外的进行重排序。

当然，锁保障原子性、可见性、有序性是有前提的：

+ 这些线程在访问同一组共享数据的时候必须使用同一个锁
+ 对于任意一个线程，即使仅仅是对共享数据的读取操作，也必须是持有锁的情况下进行

所以锁更像是一个协议，协议的内容就是上面的前提。

## 锁的几个概念

**可重入性**

当一个线程持有一个锁的时候还能够继续成功申请该锁，那么就称这个锁是可重入的。

实现原理为，锁对象会包含一个计数器，每次线程获取一个可重入锁时计数器就会加一，释放时就会减一。

**锁的争用与调度**

锁可以被看做多线程的一种排他性资源。在java中锁的调度策略包括公平策略与非公平策略。内部锁属于非公平锁，显式锁既支持公平锁又支持非公平锁。

**锁的粒度**

一个锁实例可以保护一个或者多个共享数据。一个锁保护的共享数据数量的大小就被称为锁的粒度。

**锁泄漏**

锁申请以后一直无法释放的情况就被称为锁泄漏。

## 内部锁

java中任意一个对象都有唯一一个与之关联的锁，这种锁就被称为内部锁。内部锁使用synchronized关键字实现。

```java
synchronized(内部锁){
    临界区代码
}
```

同步实例方法使用“this”作为锁，同步静态方法使用“当前类对象”作为锁。

内部锁不会导致锁泄漏，因为java编译器对内部锁做了相应的处理。

java虚拟机会为每个内部锁分配一个入口集，用来记录等待获取相应内部锁的线程。当有线程申请锁失败时就会添加到这个入口集中，当另一个线程释放锁后，jvm会使用非公平的机制唤醒一条在入口集中的线程，然后这个被唤醒的线程再去重新竞争锁。

## 显式锁

显式锁是`java.util.concurrent.locks.Lock`接口的实例，该类的默认实现为ReentrantLock，代表一个可重入的显式锁。

![image-20200301161900462](https://xbxblog2.bj.bcebos.com/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%2Fimage-20200301161900462.png)



使用显示锁首先创建Lock接口的实例，然后通过Lock.lock()方法申请显式锁，然后在临界区内访问共享数据，然后通过Lock.unlock()释放锁。

![image-20200301162245818](https://xbxblog2.bj.bcebos.com/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%2Fimage-20200301162245818.png)

显式锁不像内部锁那样由编译器规避锁泄漏问题，所以在使用显式锁之后要及时释放锁，防止锁泄漏。

显式锁既支持公平锁也支持非公平锁，可以通过ReentrantLock(boolean fair)指定。默认为非公平锁。

**读写锁**

显式锁的默认实现ReentrantLock同时只允许一个线程读取或更新共享数据。读写锁是一种改进的显式锁，它允许多个线程同时读取共享变量，但是只允许一个线程更新共享变量。任何线程在读取共享变量时，其他线程无法更新这些变量；一个线程在更新共享变量时，其他线程都无法读取或更新这个变量。

读写锁的实现是通过一个锁对象扮演两种角色实现：读锁和写锁。当读取共享数据时使用读锁进行加锁，当更新共享数据时使用写锁进行加锁。

ReentrantReadWriteLock是一个读写锁的实例。他是一个可重入锁，同时也支持锁的降级，即在写锁的情况下可以继续获得相应的读锁。

![image-20200301164903218](https://xbxblog2.bj.bcebos.com/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%2Fimage-20200301164903218.png)

# volatile

volatile用于修饰共享可变变量，即没有使用final关键字修饰的实例变量或者静态变量。volatile可以用来保障可见性和有序性，但是在原子性方面只可以保障volatile变量操作的原子性，即读写这个变量。

volatile对可见性和有序性的保障也是通过内存屏障实现的。在一个voaltile变量的写操作之前会插入一个释放屏障，该屏障保证volatile变量的写操作之前变量更新可以在volatile之前刷入缓存中，在volatile变量的写操作之后会插入一个存储屏障，它保障了voaltile的写操作可以在写完立即刷新进缓存中。这两个屏障也保障了对volatile变量的操作不可以与其他的操作进行重排序。

同样在volatile变量读取时，也会插入相应的内存屏障：加载屏障和获取屏障。加载屏障保证了在读取volatile变量之前会将其他处理器对变量所作的更新刷新至当前缓存。从而保障了voaltile变量读取的正确性。这两个变量也保证了有序性。

volatile关键字也会给JIT编译器相应提示，使其不会针对该变量做一些可能导致可见性问题的优化措施。

volatile在修饰一个数组变量时，其只能保障数组对象，并不能保障数组内元素。修饰对象也是这样。

volatile并不具备互斥性。

# CAS

那么什么是CAS，它可以做什么？

CAS（Compare And Swap）是一种处理器指令的称呼。

例如一个volatile修饰的整数型变量i，他需要执行i++操作。由于该操作实际是i=i+1这种操作，涉及到一次变量读取，一次变量更新，而volatile只能保证i的读取或更新的原子性。所以这个操作可能会存在覆盖更新的问题。当然为了解决这个问题可以使用锁来保证同步，但是锁的开销太大了。这里可以用CAS操作，CAS能够将read-modify-write和if-then-act转换为原子操作。

CAS的内部原理是通过比较(Compare )和交换(Swap)来实现。它通过从硬件方面进行保证了这个比较交换的原子性。如要将共享变量的i值从1更新为2，那么cas会先读取内存中的i变量值，如果等于1则更新为2。从读取到更新这个操作是原子性的。类似于：

![image-20200302195504015](https://xbxblog2.bj.bcebos.com/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%2Fimage-20200302195504015.png)

这个过程如果返回false。则表示更新失败，因为别的线程已经抢先更新了。这时通常需要循环更新，直到更新成功。

![image-20200302195618976](https://xbxblog2.bj.bcebos.com/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%2Fimage-20200302195618976.png)

CAS只能保障共享变量操作的原子性，并不会保障可见性。

## 原子变量类

原子变量类是基于CAS实现的能保障对共享变量进行read-modify-write更新的原子性和可见性的一组工具类！！！

其内部通过维护一个volatile变量来实现可见性，通过CAS实现原子性。

![image-20200302201845118](https://xbxblog2.bj.bcebos.com/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%2Fimage-20200302201845118.png)

以AtomicLong为例：

![image-20200302201926293](https://xbxblog2.bj.bcebos.com/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%2Fimage-20200302201926293.png)

使用时则是使用这些原子变量类来代替一般的变量类。如：

```java
private final AtomicLong requestCount = new AtomicLong(0); //使用AtomicLong代替Long类型

requestCount.incrementAndGet(); //功能类似requestCount++操作
```

# static和final

当使用static修饰一个变量时可以保证在使用时是已经初始化完成的，对应的值是默认值而不是初始值。

可以使用这个原理来实现线程安全的单例模式。

使用final修饰的变量可以在使用时保证已经初始化完毕，其原理是通过禁止构造方法重排序实现的。对于引用类型的final变量，其还保证在使用这个对象时该对象时已经初始化完毕的。

# 总结

![image-20200302210330639](https://xbxblog2.bj.bcebos.com/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%2Fimage-20200302210330639.png)
