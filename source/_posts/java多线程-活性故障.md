---
title: java多线程-活性故障
author: XIA
categories:
  - null
tags:
  - null
date: 2020-03-08 20:40:06
---

# 死锁

如果两个或更多的线程相互等待对方而永远暂停，那么就称这些线程发生了死锁。其典型场景为线程T1持有锁L1申请锁L2，线程T2持有锁L2申请锁L1，T1只有获取了L2后才会释放L1，T2只有获取了L1才会释放L2，这样这两个线程都会一直等待对方释放锁，两个线程都被暂停了。这样就发生了死锁。

![image-20200308204700288](https://xbxblog2.bj.bcebos.com/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E6%B4%BB%E6%80%A7%E6%95%85%E9%9A%9C%2Fimage-20200308204700288.png)

## 死锁产生的条件

线程产生死锁，那么这些线程及相关资源将满足以下全部条件。

+ 资源互斥：每一个资源之只能被一个线程使用。
+ 资源的不可抢夺：涉及的资源只能被持有者主动释放，而无法被资源的持有者和申请者之外的第三方线程所抢夺。
+ 占用并等待资源：涉及的线程当前至少持有一个资源并申请其他资源，而这些资源恰好被其他线程持有。在这个等待的过程中，线程并不释放其已经持有的资源。
+ 循环等待资源：涉及的线程必须在等待别的线程持有的资源，而这些线程又反过来等待第一个线程所持有的资源。

当产生死锁时上面的条件一定会同时成立，但是上面条件同时成立时并不一定会发生死锁。

我们把锁看作是一种资源，这种资源符合“资源互斥”和“资源不可抢夺”，那么可以产生死锁的代码特征就是在持有一个锁的情况下去申请另一个锁，通常表现为锁的嵌套。

![image-20200308210254922](https://xbxblog2.bj.bcebos.com/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E6%B4%BB%E6%80%A7%E6%95%85%E9%9A%9C%2Fimage-20200308210254922.png)

## 死锁的规避

规避死锁的几种方式：

+ 粗锁法：使用粗粒度的锁代替多个锁。这样可以避免多个锁之间的嵌套，但是这样也会降低程序的并发性。
+ 锁排序法：相关线程使用统一的顺序申请锁。当所有相关线程按照同一个顺序去申请锁，就不会产生“循环等待资源”。这样就避免了死锁的产生。
+ 使用ReentrantLock.tryLock(long timeout, TimeUnit unit)申请锁：该方法允许为申请锁的操作设置一个超时时间，在时间内申请成功则返回true，如果在允许时间内没有申请到锁则返回false。这样可以避免死锁发生时线程的无限等待。
+ 使用开放式调用：有时我们在调用开源库中的某个方法时会发生死锁，出现这种情况很多情况下是由于我们的方法持有锁。开放式调用就是指在一个方法调用外部方法（比如一个开源库中的方法）的时候不持有任何锁。而我们的方法可以使用锁之外的其他线程同步方式。
+ 不使用锁：不使用锁当然就不会产生死锁了。线程同步方式可以选择其他锁的替代品，如：volatile，线程持有对象等。

## 死锁的恢复

当死锁发生时如果使用的是内部锁或者通过Lock.lock()申请的锁，此时只有通过重启虚拟机来恢复死锁。而如果锁的申请使用的是Lock.lockInterruptibly()调用实现的，那么这些锁导致的死锁可以通过线程中断机制来恢复。

实现死锁恢复的思想是：定义一个守护线程，它通过间隔循环执行`java.lang.management.ThreadMXBean.findDeadlockedThreads()`来获取发生死锁的线程编号，然后向其发送中断信号来使中断线程抛出InterruptedException异常，然后捕获进行相应处理。

但是我们不能指望亡羊补牢式的死锁恢复机制，而是应该从根本上对死锁进行规避。

# 锁死

等待线程由于唤醒其所需的条件永远无法成立，或者其他线程无法唤醒这个线程而一直处于非运行状态导致其任务一直无法进展，那么我们就称这个线程发生了死锁。通俗来说就是这个线程的wait操作无法被唤醒来了。

## 锁死产生的原因

+ 信号丢失锁死：典型的例子就是执行Object.wait()/Condition.await()前没有对保护条件进行判断，而此时保护条件已经成立，即另一个线程已经执行过notify方法。这样执行等待的线程就会一直无法收到唤醒通知，导致了锁死的发生。

+ 嵌套监视器锁死：代码类似如下，其中一个线程在持有锁moitorX的情况下执行了wait操作，但是另一个方法只有在持有锁monitorX的情况下才可以执行notify操作。这样就导致wait一直无法被唤醒，发生锁死。

  ![image-20200308214507011](https://xbxblog2.bj.bcebos.com/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E6%B4%BB%E6%80%A7%E6%95%85%E9%9A%9C%2Fimage-20200308214507011.png)

# 线程饥饿

指线程一直无法获得其所需的资源而导致其任务一直无法进展的一种线程活性故障。

其典型的场景是，在高争用唤醒下使用非公平模式的锁，导致一个线程永远无法获取到锁的使用权。这样就发生了线程饥饿。

其实死锁也是一种线程饥饿。

# 活锁

在争用锁的过程中，屡战屡败，屡败屡战。就是一直申请不到。