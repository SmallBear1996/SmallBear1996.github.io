---
title: java多线程-硬件基础与内存模型
author: XIA
categories:
  - 多线程
tags:
  - null
date: 2019-03-11 20:00:44
---

# 硬件基础

一部分硬件的引入是为了解决一部分问题，然而这部分硬件又会引入新的问题。为了解决这些新问题，硬件设计者又会引入新的其他硬件。

## 高速缓存

为了弥补处理器与内存之间的速度差异，在主内存与处理器之间引入了高速缓存。每个处理器都具有高速缓存，现代处理器一般具有多个缓存层次通常被称为一级缓存、二级缓存、三级缓存等。一般一级缓存是最靠近处理器的，其容量相对较小访问速率高。而靠近内存的高速缓存则相对容量较大，访问速率较慢。

高速缓存中保存的数据可以看作内存的副本，在处理器要访问某内存地址中的数据时，会先试图访问高速缓存，当未命中后才会访问内存。

高速缓存中的数据结构类似于散列表，key是一个内存地址，value是内存数据的副本或准备写入内存的数据。从内部结构看，高速缓存是一个拉链散列表，它包含若干桶，每个桶又包含若干缓存条目。

![image-20200311202429250](https://xbxblog2.bj.bcebos.com/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-jmm%2Fimage-20200311202429250.png)

每个缓存条目可以进一步划分为Tag、Data Block、Flag三部分。Data Block是高速缓存与内存之间的数据交换最小单元被称为缓存行，Tag包含了缓存行中数据相应的内存地址的部分信息，Flag表示相应缓存行的状态信息。

![image-20200311202726080](https://xbxblog2.bj.bcebos.com/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-jmm%2Fimage-20200311202726080.png)

处理器在对内存执行访问操作时会将地址解码，内存地址包括tag、index、offset三部分。其中index相当于桶编号，tag则用来定位桶下的缓存行，由于一个缓存行包含多个变量，offset是缓存行内的位置偏移用来定位变量。

## 缓存一致性协议

引入高速缓存后，由于每个处理器都拥有自己的高速缓存，并且处理器之间并不能相互访问对方的高速缓存，就会导致更新丢失、读脏数据等问题。解决这个问题的方案就是缓存一致性协议。MESI协议就是一种使用较广的缓存一致性协议。MESI将缓存条目状态划分为：Modify、Exclusive、Shared、Invalid四种。

+ I：表示该缓行中数据无效
+ S：表示该缓存行数据与主内存中一致，如果其他处理器中高速缓存也存在该缓存条目，那么状态也应该为S
+ E：表示该处理器独占该缓存行，其他处理器上的高速缓存当前都不应该保留该数据的有效副本
+ M：表示缓存行中的数据已经被修改

MESI还定义了一组消息，可以类比HTTP理解为一组协议。多个处理器之间通过总线，发送不同类型的消息，来对高速缓存中的数据进行同步。

![image-20200313192910013](https://xbxblog2.bj.bcebos.com/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-jmm%2Fimage-20200313192910013.png)

**MESI流程举栗：**

如果一个处理器P0要往地址A写数据。任何一个处理器在执行内存写时都必须拥有该数据的所有权，所以P0在根据地址A找到相应缓存条目后，若缓存条目Flag为M或E，则说明处理器已经拥有相应数据所有权。此时可以将数据直接写入，并将Flag更新为M。若缓存条目Flag不为M或E，处理器P0则需要先发送Invalidate消息，其他处理器收到该消息后会将该缓存条目Flag更新为I，并回复Invalidate Acknowledge消息，P0收到所有处理器回复的Invalidate Acknowledge后才会将数据写到缓存条目中，并更新Flage为M。

这样通过状态和消息就完成了高速缓存的数据一致问题，但是这样就引入了另一个问题，每次更新数据会伴随着一系列的消息发送与状态更改，降低了处理效率。为了解决这个问题，又引入了另外的硬件：写缓冲器和无效化队列。

## 写缓冲器与无效化队列

写缓冲器是处理器内部的一个容量比高速缓存还小的私有高速存储组件，每个处理器都有其写缓冲器，写缓冲器内部可包含若干条目。

在引入写缓冲器后，处理器执行一个写操作时会做这样的处理：当高速缓存中的缓存条目Flag不为M或E时，会将要写入的值存入写缓冲器中，然后向总线发送Invalidate消息，等收到所有处理器返回的Invalidate Acknowledge消息后再将写缓冲器中的值写入高速缓存中。

在处理器接收到Invalidate消息后并不立即将消息中执行的缓存行Flag更新为I，而是先存到无效化队列，然后就回复Invalidate Acknowledge消息，从而减少处理器的等待时间。

此时因为引入了写缓冲器与无效化队列又产生了新的问题：内存重排序和可见性问题。

**存储转发**

一个处理器在执行了写操作，然后立即读取这个写入地址的值，但是由于写缓冲器的原因导致读取到的值并不是最新的，产生了脏读。存储转发就是为了解决这个问题，使用存储转发后，在处理器读取一个地址时，会将读取这个操作转发到写缓冲器，若写缓冲器皴法相应的值则直接返回写缓冲器中的值。

存储转发只解决了同一个处理器两次读取相同值所引起的读脏数据问题。

## 内存屏障

为了解决由于因为写缓冲器和无效化队列带来的内存重排序和可见性问题，cpu引入一组统称为内存屏障的指令。包括：LoadLoad屏障、LoadStore屏障、StoreStore屏障、StoreLoad屏障。这些内存屏障可以禁止相应的重排序。如StoreLoad指令则是禁止指令前的Store操作与指令后的Load指令重排序。

![image-20200313201757781](https://xbxblog2.bj.bcebos.com/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-jmm%2Fimage-20200313201757781.png)

内存屏障是通过处理器禁止相应的指令重排序，并且刷新写缓冲器与无效化队列实现。

## 内存屏障的应用

volatile、synchronized、final关键字的实现中就使用了内存屏障。

**volatile**

jvm会在volatile写操作之前插入LoadStore和StoreStore屏障，在volatile读操作之后会插入LoadLoad和LoadStore屏障。![image-20200313203331931](https://xbxblog2.bj.bcebos.com/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-jmm%2Fimage-20200313203331931.png)

**synchronized**

jvm会在monitorenter对应的指令前插入一个获取屏障，在monitorenter前插入释放屏障。这样就保障了临界区内的代码不会被重排序到临界区外，再加上锁的排他性就使临界区内的代码具有原子性。

**final**

如果一个构造器中要对一个final变量进行赋值，那么会在赋值后插入一个StoreStore内存屏障，来禁止它与后面的任何写操作进行重排序，由于对象发布也是一个写操作，所以就会保证在对象发布前final已经初始化。

## 总结

![image-20200313205915994](https://xbxblog2.bj.bcebos.com/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-jmm%2Fimage-20200313205915994.png)

为了解决主内存速度慢的问题引入了高速缓存，为了解决高速缓存同步问题，引入了缓存一致性协议，为了解决缓存一致性协议带来的性能损失，引入了写缓冲器与无效化队列，为了解决写缓冲器与无效化队列引起的内存重排序与可见性问题引入了内存屏障指令。

# JAVA内存模型

## 什么是内存模型

缓存一致性协议确保了一个处理器对某个内存地址进行的写操作的结果最终能被其他处理器所读取。所谓的“最终”就是带有不确定性，换言之，即一个处理器对共享变量所作的更新具体什么时候能够被其他处理器读取这一点，缓存一致性协议本身是不保证的。写缓冲器、无效化队列都可能导致一个处理器在某一时刻读取到共享变量的旧值。因此计算机必须解决一个这样的问题----一个处理器对共享变量所作的更新在什么时候或者说在什么情况下才能够被其他处理器所读取，即可见性问题。可见性问题又衍生出一个新的问题-----一个处理器先后更新多个共享变量的情况下，其他处理器是以何种顺序读取到这些更新的，即有序性问题。

用于回答上述问题的模型就被称为内存一致性模型，也被称为内存模型。不同处理器架构有着不同的内存模型，因此这些处理器对有序性的保障程度不同，表现为对内存重排序支持的不同。

JAVA作为一个跨平台语言，为了屏蔽不同处理器的内存模型差异，以便Java开发人员不必根据不同处理器编写不同代码，它必须定义自己的内存模型，这个模型就被称为`java内存模型`。

## 什么是Java内存模型

Java内存模型定义了final、volatile、synchronized关键字的行为并确保正确同步的java程序能够正确运行在不同架构处理器上。从开发人员的角度看，java内存模型作为一个模型，它为我们解答了以下几个线程安全方面的问题：

+ 原子性问题。针对实例变量、静态变量的读写操作。哪些具备原子性，哪些不具备原子性。
+ 可见性问题。一个线程对实例变量、静态变量进行的更新在什么情况下能够被其他线程所读取。
+ 有序性问题。一个线程对多个实例变量、静态变量进行的更新在什么情况下其他线程看来可以是乱序的。

在原子性方面，java内存模型规定对long、double之外的基本数据类型及引用类型的共享变量进行读写操作都具有原子性，另外，java内存模型还规定对volatile修饰的long、double类型共享变量进行读写操作也是具有原子性的。

对于可见性问题和有序性问题，Java内存模型则使用happens-before来解答。

> 某个线程执行时，内存中的一份数据，会存在于该线程的工作存储中（***working memory，是cache和寄存器的一个抽象，这个解释源于《Concurrent Programming in Java: Design Principles and Patterns, Second Edition》§2.2.7，原文：Every thread is defined to have a working memory (an abstraction of caches and registers) in which to store values. 有不少人觉得working memory是内存的某个部分，这可能是有些译作将working memory译为工作内存的缘故，为避免混淆，这里称其为工作存储，每个线程都有自己的工作存储\***），并在某个特定时候回写到内存。

## happens-before

如果操作1 happens-before 操作2，那么第操作1的执行结果将对操作2可见，而且操作1的执行顺序排在第操作2之前。

**happens-before内容：**

- 程序次序规则： 在一个单独的线程中，按照程序代码的执行流顺序，（时间上）先执行的操作happen—before（时间上）后执行的操作
   （**同一个线程中前面的所有写操作对后面的操作可见**）
- 管理锁定规则：一个unlock操作happen—before后面（时间上的先后顺序）对同一个锁的lock操作。
   （**如果线程1解锁了monitor a，接着线程2锁定了a，那么，线程1解锁a之前的写操作都对线程2可见（线程1和线程2可以是同一个线程）**）
- volatile变量规则：对一个volatile变量的写操作happen—before后面（时间上）对该变量的读操作。
   （**如果线程1写入了volatile变量v（临界资源），接着线程2读取了v，那么，线程1写入v及之前的写操作都对线程2可见（线程1和线程2可以是同一个线程）**）
- 线程启动规则：Thread.start()方法happen—before调用用start的线程前的每一个操作。
   （**假定线程A在执行过程中，通过执行ThreadB.start()来启动线程B，那么线程A对共享变量的修改在接下来线程B开始执行前对线程B可见。注意：线程B启动之后，线程A在对变量修改线程B未必可见。**）
- 线程终止规则：线程的所有操作都happen—before对此线程的终止检测，可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。
   (**线程t1写入的所有变量，在任意其它线程t2调用t1.join()，或者t1.isAlive() 成功返回后，都对t2可见。**)
- 线程中断规则：对线程interrupt()的调用 happen—before 发生于被中断线程的代码检测到中断时事件的发生。
   (**线程t1写入的所有变量，调用Thread.interrupt()，被打断的线程t2，可以看到t1的全部操作**)
- 对象终结规则：一个对象的初始化完成（构造函数执行结束）happen—before它的finalize（）方法的开始。
   (**对象调用finalize()方法时，对象初始化完成的任意操作，同步到全部主存同步到全部cache。**)
- 传递性：如果操作A happen—before操作B，操作B happen—before操作C，那么可以得出A happen—before操作C。
   （**A h-b B ， B h-b C 那么可以得到 A h-b C**）

## 总结

每个线程都有自己的工作内存，一般的操作都是在工作内存(位于高速缓存！！！)中进行，之后再更新回主内存。那么什么时候、什么情况下触发刷新工作内存到主内存操作呢？如果不解决这个问题就会出现原子性、可见性、有序性问题。而这个**“何时”**，就是Java内存模型要解决的问题。现在要做的就是如何解决这三个问题了，解决第一个问题方案是定义jvm对非long、double类型变量赋值的原子性；第二和第三个问题是，Java内存模型通过定义了happens-before原则这种方案，

java内存模型主要围绕“什么（what）”而不是“如何（how）”的角度来描述java语言对可见性、有序性的保证。也就是说他解答的是要怎么样，而不是怎么才能这样。比如，在原子性方面他就要保证long、double之外的基本数据类型及引用类型的共享变量进行读写操作都具有原子性，他规定了只能这样！！！而不负责解决如何才能这样。还有对可见性和有序性的规定，他就规定了happens-before原则，但是具体怎么实现这个原则，它并不管。

而这些happens-before规则需要最终由java虚拟机、编译器以及处理器一同协作来完成落实。内存屏障就是jvm、编译器、处理器之间用来沟通的“纽带“。当遇到一个内存屏障指令时，jvm、编译器、处理器就会按照规定该不优化代码的不优化代码，该消停的不排序的时候不自作主张排序，该刷新写缓冲器和无效化队列时候就刷新下等等等等。。。

