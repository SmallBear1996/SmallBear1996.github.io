---
title: 类加载机制
author: XIA
categories:
  - jvm
tags:
  - jvm
date: 2019-11-03 21:38:29
---

# 概述

类的加载机制就是将描述类的数据加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型。

类从加载到虚拟机虚拟机开始，到卸载出内存为止。它的整个过程包括：加载、验证、准备、解析、初始化、使用、卸载。其中验证、准备、解析这三个阶段称为连接。

![](C:\Users\xia\Desktop\classLife.png)

java虚拟机规范规定了有且只有五种情况会触发类的加载过程：

1. 遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化行为。这四条指令常见的场景为:使用new关键字进行对象实例化、读取或设置一个静态字段、调用一个类的静态方法。
2. 通过反射对一个类进行调用时，如果这个类没有被加载，则会触发加载过程。
3. 初始化一个类时，发现父类没有进行过初始化，则需要先触发其父类的初始化。
4. 虚拟机启动时，用户指定一个包含main方法的主类，虚拟机会先初始化这个类。
5. 如果一个MethodHandle实例最后解析结果REF_getStatic。。。

# 加载

在加载阶段虚拟机主要做3件事情:

+ 通过一个类的全限定名来获取定义此类的二进制字节流
+ 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
+ 在内存中生成一个代表这个类的java.lang.Class对象，作为方法去这个类的各种数据的访问入口。在hotspot中这个对象存储在方法区

由于数组类本身不通过类加载器创建，它是由虚拟机创建的。但是数组类的元素类型（数组去掉所有维度的类型）是由类加载器创建的。由于每个类对象都需要类加载器信息，所以对数组类获取类加载器信息的情况分为三种：

1. 若数组类的元素类型是引用类型，则先加载这个引用类型的类。然后将数组类的类加载器信息标志为引用类型的类加载器信息。
2. 如果数组类的元素类型不是引用类型，如int等。则数组类的加载器信息标志为引导类加载器。
3. 数组类的可见性和组件类型一致，如果组件类型不是引用类型，那么数组的可见性默认为public。

# 验证

验证是为了保证class文件的字节流中包含的信息符合虚拟机的要求，并且不危害虚拟机自身安全。

验证主要包括以下四个阶段：

1. 文件格式验证

   包括对魔数、主次版本号、是否有不支持的常量、指向常量池的索引是否有不存在的或不符合类型的常量、class文件各个部分是否有被删除或附加的其他信息等。

2. 元数据验证

   主要对字节码描述的信息进行语义分析，例如：这个类是否有父类、是否继承了使用final修饰的类等

3. 字节码验证

   对数据流和控制流分析，确定程序的语义是合法的、符合逻辑的。主要用来杜绝类似问题：操作栈中存放了init类型数据却被当作long来处理、跳转指令跳转到方法体以外的字节码指令上、父类对象赋值给子类数据类型。

4. 符号引用验证

   在稍后的解析过程中会将类里的符号引用转换为直接引用，该校验的目的是为了确保解析动作的正常执行。

# 准备

准备阶段是正式为类变量分配内存并设置初始值到的阶段。这些变量所使用的内存都将在方法区中进行分配。这个阶段所赋值的变量仅为类变量即使用static修饰的变量。

如：`public static int value = 1;`，变量在准备阶段过后的初始值为0，而不是1。因为这个时候尚未执行任何java方法，而把value赋值为1的putstatic指令是在程序被编译后，存放在`<clinit>()`方法中。所以把value赋值为1是在初始化阶段才会执行的。

如果一个字段被static final修饰，那么在编译后这个字段的属性表中会存在ConstantValue属性，在准备阶段这个变量会被初始化为ConstantValue的值。

# 解析

















