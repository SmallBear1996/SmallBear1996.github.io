---
title: 系统的学一次Netty
author: XIA
categories:
  - null
tags:
  - null
date: 2020-07-13 20:47:11
---

# Linux网络IO模型

Linux的内核将所有外部设备都看作一个文件，对一个文件的读写会调用内核提供的系统命令，返回一个文件描述符。而对socket的操作也会有相应的描述符，成为socket描述符。

根据unix网络编程模型，大致可以分为以下几类IO模型。

+ 阻塞型：最常用的io模型，所有的文件操作都是阻塞的。以套接字为例，在进程空间中调用recvfrom，其系统调用直到数据包到达且被复制到应用进程的缓冲区中或者发生错误才返回，在此期间将一直等待。

  ![image-20200713221310833](https://blog-1253099784.cos.ap-nanjing.myqcloud.com/image-20200713221310833.png)

+ 非阻塞：当recvfrom从应用层到内核的时候，如果该缓冲区没有数据的话，系统直接返回一个EWOULDBLOCK错误，然后轮询检查这个状态，看内核是否有数据到来。

+ ![image-20200713221607374](https://blog-1253099784.cos.ap-nanjing.myqcloud.com/image-20200713221607374.png)

+ IO复用模型：Linux提供select/poll，进程通过将一个或多个文件描述符传递给select或poll调用，阻塞在select操作上，这样select/poll可以帮我们侦测多个文件描述符是否处于就绪状态。linux还提供了epoll系统调用，而且epoll解决了select/poll的多个不足，如文件描述符的限制等。

  ![image-20200713222153077](https://blog-1253099784.cos.ap-nanjing.myqcloud.com/image-20200713222153077.png)

+ 信号驱动IO：通过系统调用sigaction执行一个信号处理函数（系统调用立即返回，进程继续工作，非阻塞），当数据准备就绪时，就为进程生成一个SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据，并通知主循环函数处理数据。

  ![image-20200713223714996](https://blog-1253099784.cos.ap-nanjing.myqcloud.com/image-20200713223714996.png)

+ 异步IO：告知内核启动某个操作，并让内核在整个操作完成后(包括将数据从内核复制到用户自己的缓冲区)通知我们。这种模型与信号模型的区别是：信号驱动IO由内核通知我们何时开始一个IO操作，异步IO模型由内核通知我们操作何时已经完成。

  ![](https://blog-1253099784.cos.ap-nanjing.myqcloud.com/image-20200713223958418.png)

> 首先，解释一下这里的阻塞与非阻塞：
>
> 阻塞IO，指的是需要内核IO操作彻底完成后，才返回到用户空间，执行用户的操作。阻塞指的是用户空间程序的执行状态，用户空间程序需等到IO操作彻底完成。传统的IO模型都是同步阻塞IO。在java中，默认创建的socket都是阻塞的。
>
> 其次，解释一下同步与异步：
>
> 同步IO，是一种用户空间与内核空间的调用发起方式。同步IO是指用户空间线程是主动发起IO请求的一方，内核空间是被动接受方。异步IO则反过来，是指内核kernel是主动发起IO请求的一方，用户线程是被动接受方。

> 无论是Socket的读写还是文件的读写，在Java层面的应用开发或者是linux系统底层开发，都属于输入input和输出output的处理，简称为IO读写。在原理上和处理流程上，都是一致的。区别在于参数的不同。
>
> 用户程序进行IO的读写，基本上会用到read&write两大系统调用。可能不同操作系统，名称不完全一样，但是功能是一样的。
>
> 先强调一个基础知识：read系统调用，并不是把数据直接从物理设备，读数据到内存。write系统调用，也不是直接把数据，写入到物理设备。
>
> read系统调用，是把数据从内核缓冲区复制到进程缓冲区；而write系统调用，是把数据从进程缓冲区复制到内核缓冲区。这个两个系统调用，都不负责数据在内核缓冲区和磁盘之间的交换。底层的读写交换，是由操作系统kernel内核完成的。

参考：https://blog.csdn.net/crazymakercircle/article/details/85858596

# NIO入门

## 传统BIO编程

传统bio的线程模型是线程个数和并发访问数呈1:1的关系，当一个请求到来后会为之创建对应的处理线程，用来处理到来的请求。当请求处理完成后线程就会被销毁。

这种线程模型最大的问题 就是缺乏伸缩性，当客户端访问量增加后，服务端的线程个数会迅速膨胀，将导致系统性能急剧下降，导致堆栈溢出，无法创建新线程等问题。

这种IO模型的编程方式通常是一个线程对server线程进行阻塞，当有请求连接进入时，就会新建线程去处理这个链接，然后server线程会继续阻塞。

![image-20200713225941736](https://blog-1253099784.cos.ap-nanjing.myqcloud.com/image-20200713225941736.png)

## 伪异步IO编程

为了解决传统同步阻塞IO面临的一个链路需要一个线程处理的问题，而引入了一个专门用于处理客户端请求的线程池。通过线程池可以灵活的调配资源，设置线程的最大值，防止由于海量链接并发导致线程耗尽。

通过线程池和任务队列可以实现这种伪异步的io框架，当有新的请求到来时，将客户端的请求封装为Task，投放到线程池的任务队列中，让线程池使用内部维护的线程处理任务。

![image-20200713231158473](https://blog-1253099784.cos.ap-nanjing.myqcloud.com/image-20200713231158473.png)

使用伪异步IO存在的弊端主要是，在进行读取和写入操作时，会被一直阻塞。由于InpuStream与OutputStream的阻塞特性，只有在数据被读取或写入完毕或者发生异常时才会返回。

假设我的系统需要使用一个第三方的系统，我们无法保证第三方系统的性能与稳定性，比如当我们对第三方系统进行一次请求响应的平均时间由于第三方的原因变成60秒，这样就会导致我们的系统中线程池中线程都会被阻塞60秒的时间，此时如果请求量较大就会将线程池中线程耗尽，导致客户以为我们系统崩溃的假象。

## NIO编程

与BIO的Socket和ServerSocket类似，NIO也提供了SocketChannel和ServerSocketChannel两种套接字实现，这两种新增的通道都支持阻塞和非阻塞两种模式。

NIO中主要概念：

+ Buffer:是一个对象，包含一些要写入或者读出的数据。在NIO中所有数据都是用缓冲区处理的，任何访问NIO中的数据都是通过缓冲区进行的。
+ Channel：网络数据通过Channel读取和写入，通道与流之间的不同在于，通道是双向的，流是单向的。
+ Selector：多路复用器。提供选择已经就绪的任务的能力，简单来讲，Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读写时间，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey获取就绪Channel的集合，进行后续的IO操作。一个Selector可以同时轮询多个Channel。

这种使用JDK的NIO程序编写逻辑：

+ 打开ServerSocketChannel，用于监听客户端的链接。绑定监听端口并设置为非阻塞模式。
+ 创建Reactor线程，创建多路复用器。将ServerSocketChannel注册到Reactor线程的多路复用器Selector上，监听ACCEPT事件。
+ 在多路复用器所在线程的run方法中无限循环获取准备就绪的key。
+ 将接收到的SocketChannel也注册到selector上，并监听读操作。
+ 异步读取客户端请求消息到缓冲区

使用NIO的优点：

1. 客户端发起的链接操作都是异步的，可以通过多路复用器注册连接事件等待后续，不需要像之前的客户端那样同步阻塞。
2. SocketChannel的读写操作都是异步的，如果没有可读写的数据它不会同步等待，直接返回，这样IO线程就可以处理其他的链路，不需要同步等待这个链路的可用。
3. 由于Seletcor在Linux等操作系统使用epoll实现。所以它没有链接数量的限制，且具有很好的性能。

## AIO编程

AIO使用了系统底层的异步io支持，与多路复用的区别在于，多路复用是在内核缓存准备就绪时（比如当数据到达网卡，内核需要将数据从网卡复制到内核缓存中，在复制完成时，这就是数据准备就绪了。）使用epoll通知用户线程，用户线程阻塞地去将内核空间中的数据复制到用户空间中。

而aio则会通过系统把数据准备与数据从内核空间复制到进程缓存的工作都做完，然后在完成时通过发送信号到应用中，执行应用的回调结果，对应用缓存中的数据进行操作。

但是aio在linux并不完善。现在的异步io还是主要使用多路复用器。



**按照linux中规定，java中通过selector实现的nio并不算是异步io，而是非阻塞io。java提供的aio才算是真正的异步非阻塞io**



# 使用Netty进行简单的开发

使用Netty的步骤：包括建立NIO线程组，初始化并设置启动类，设置Handler等。

# TCP粘包/拆包问题

由于Netty之间建立的是tcp的请求通道，并不是针对某一个应用层协议，所以它本身不能控制应用层数据组合。所以就会产生粘包、拆包问题。

解决的方式就是在Netty应用中加入适当的分割协议，如根据指定长度、根据特定的字符进行分割。Netty已经为我们提供了很多用于处理粘包、拆包的Handler。使用时只需要将用于处理粘包、拆包的Handler加入pipeline即可。如：

![image-20200714215537434](https://blog-1253099784.cos.ap-nanjing.myqcloud.com/image-20200714215537434.png)

Netty提供了很多处理粘包与拆包策略的Handler可供使用：

+ LineBasedFrameDecoder:根据换行符处理半包问题
+ DelimitedBasedFrameDecoder：根据分隔符处理半包问题
+ FixedLengthFrameDecoder：根据固定长度处理半包问题
+ StringDecoder：将数据编码为字符串

# 编解码技术

Java自带的编解码技术有着以下缺点：

+ 无法跨语言
+ 序列化后码流太大
+ 序列化性能低

所以需要使用第三方的编解码框架来应对编解码需求，主流的有Protobuf、Thrift、Marshalling等。

Netty本身提供了对这些编解码器的支持，开箱即用。































